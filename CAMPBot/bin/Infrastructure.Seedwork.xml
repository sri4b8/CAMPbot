<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Infrastructure.Seedwork</name>
    </assembly>
    <members>
        <member name="T:Infrastructure.Seedwork.AbstractActionPolicy">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.IActionPolicy">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.AbstractActionPolicy.Execute(Infrastructure.Seedwork.ActionExecutionContext,System.Action)">
            <summary>
            This is not "virtual" by design. All policies that extend this class must implement
            OnBeforeActionExecute, OnAfterActionExecute and OnActionError methods to apply
            the policy.
            </summary>
            <param name="context"></param>
            <param name="action"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.AbstractActionPolicy.OnBeforeExecuteAction(Infrastructure.Seedwork.ActionExecutionContext)">
            <summary>
            Invoked before an action is executed.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.AbstractActionPolicy.OnAfterExecuteAction(Infrastructure.Seedwork.ActionExecutionContext)">
            <summary>
            Invoked after an action is successfully executed (i.e., no exception was thrown).
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.AbstractActionPolicy.OnActionError(Infrastructure.Seedwork.ActionExecutionContext,System.Exception)">
            <summary>
            Invoked if the action being executed threw an exception.
            </summary>
            <remarks>
            Not guaranteed to be invoked if a policy throws another exception.
            </remarks>
            <param name="context"></param>
            <param name="ex"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.ActionExecutionContext">
            <summary>
            Holds data tracked by policies during an action run.
            </summary>
            <remarks>
            <p>
            There are two kinds of data tracked by policies during an action run:
            1. Data for a single execution of the action. This data is reset if the action fails and is
            retried. This data is called <c>RunData</c>.
            2. Data across multiple executions of the action (which happens if the action fails and is retried).
            This data is called <c>SharedData</c>.
            </p>
            </remarks>
            <threadsafety static="true" instance="true"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.ActionExecutionContext.AttemptCount">
            <summary>
            Number of execution attempts of the action already completed.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Application.ServiceBase">
            <summary>
            Base class for all application services.
            </summary>
            <remarks>
            A wrapper class that will Open an <c>UnitOfWorkScope</c> and executes the action in that scope.
            The <see cref="T:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings"/> are used to determine 2 things.
            1) Decide on which <c>IManageUnitsOfWork</c> to begin in the scope.
            2) Whether or not to begin a <c>TransactionScope</c>
            </remarks>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainerAware"/>
            <author>Srinivas Gundu</author>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IContainerAware">
            <summary>
            Interface to be implemented by objects that need access to the container.
            </summary>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IConfigureContainer"/>
            <author>Vamsee Mohan Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.DI.IContainerAware.Container">
            <summary>
            The container will set this property on objects implementing this interface.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Application.ServiceBase.#ctor">
            <summary>
            Picks up all the IManageUnitsOfWork.
            No transaction scope is opened.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Application.ServiceBase.DefaultScopeSettings">
            <summary>
            The settings to be used when it is not specified in the <c>Execute</c> methods.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Application.ServiceBase.Container">
            <summary>
            The container that was used to create this service.
            </summary>
            <remarks>
            <p>
            Services are typically registered outside of unit of work scope. For example,
            if we have a class called <c>CustomerService</c> that extends <see cref="T:Infrastructure.Seedwork.Application.ServiceBase"/>,
            it would be configured in a container as follows:
            <c>
            var singleton = false;
            var unitOfWorkScope = false;
            rootContainer.RegisterType(typeof(CustomerService), singleton, unitOfWorkScope);
            </c>
            
            When a type if registered outside of unit of work scope, it is created by the root container. So
            the <c>Container</c> property would be set to the root container.
            </p>
            </remarks>
        </member>
        <member name="T:Infrastructure.Seedwork.AssertUtil">
            <summary>
            Utility class for making assertions in code.
            </summary>
            <author>Vamsee M Kamabathula</author>
            <seealso cref="T:Infrastructure.Seedwork.AssertionFailedException"/>
        </member>
        <member name="M:Infrastructure.Seedwork.AssertUtil.IsNotNull(System.Object,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="format"></param>
            <param name="args"></param>
            <exception cref="T:Infrastructure.Seedwork.AssertionFailedException">
            if <paramref name="obj"/> is <c>null</c>.
            </exception>
        </member>
        <member name="T:Infrastructure.Seedwork.AssertionFailedException">
            <summary>
            Exception thrown when an assertion fails.
            </summary>
            <author>Vamsee M Kamabathula</author>
            <seealso cref="!:Assert"/>
        </member>
        <member name="T:Infrastructure.Seedwork.BackgroundWorker">
            <summary>
            Base implementation of <see cref="T:Infrastructure.Seedwork.IBackgroundWorker"/>.
            </summary>
            <remarks>
            Background worker implementations can easily implement <see cref="T:Infrastructure.Seedwork.IBackgroundWorker"/> by 
            inheriting this class and implementing the <see cref="M:Infrastructure.Seedwork.BackgroundWorker.Run"/> method.
            </remarks>
            <example>
            The following code demonstrates a typical implementation of <c>BackgroundWorker</c>:
            <code lang="C#" source="Infrastructure.Seedwork\BackgroundWorkerExample.txt"></code>
            </example>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.IBackgroundWorker">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.IBackgroundWorker.StartWorkAsync">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.IBackgroundWorker.PauseWork">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.IBackgroundWorker.ResumeWork">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.IBackgroundWorker.StopWorkAsync">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.IBackgroundWorker.State">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.IBackgroundWorker.Name">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.BackgroundWorkersManager">
            <summary>
            
            </summary>
            <seealso cref="T:Infrastructure.Seedwork.IBackgroundWorker"/>
            <seealso cref="T:Infrastructure.Seedwork.IManageBackgroundWorkers"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainerAware"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.IManageBackgroundWorkers">
            <summary>
            Manages a set of background workers.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.IManageBackgroundWorkers.StartWorkersAsync">
            <summary>
            Starts the <see cref="T:Infrastructure.Seedwork.IBackgroundWorker">background workers</see> registered with this
            instance asynchronously.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.IManageBackgroundWorkers.StopWorkersAsync">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.IManageBackgroundWorkers.Workers">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.BackgroundWorkerState">
            <summary>
            Enumeration for difference states of a <see cref="T:Infrastructure.Seedwork.IBackgroundWorker">background worker</see>.
            </summary>
            <seealso cref="T:Infrastructure.Seedwork.IBackgroundWorker"/>
            <seealso cref="T:Infrastructure.Seedwork.BackgroundWorker"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.CompositeActionPolicy">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.AssemblyScanner">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.IAssemblyScanner">
            <summary>
            Defines the contract to be implemented by classes that can scan the various types defined in the
            application assemblies and perform some meaningful operations on the types.
            </summary>
            <remarks>
            TODO:
            </remarks>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.Assembly(System.Reflection.Assembly)">
            <summary>
            Add an Assembly to the scanning operation
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.Assembly(System.String)">
            <summary>
            Add an Assembly by name to the scanning operation
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.TheCallingAssembly">
            <summary>
            Add the currently executing Assembly to the scanning operation
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssemblyContainingType``1">
            <summary>
            Add the Assembly that contains type T to the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssemblyContainingType(System.Type)">
            <summary>
            Add the Assembly that contains type to the scanning operation
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromPath(System.String)">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromPath(System.String,System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation.  The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
            <param name="path"></param>
            <param name="assemblyFilter"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromPath(System.String,System.Predicate{System.String})">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="assemblyFilter"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromApplicationBaseDirectory">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromApplicationBaseDirectory(System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation. The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.AssembliesFromApplicationBaseDirectory(System.Predicate{System.String})">
            <summary>
            
            </summary>
            <param name="assemblyFilter"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.ExcludeAssembly(System.String[])">
            <summary>
            
            </summary>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.ExcludeType(System.String[])">
            <summary>
            
            </summary>
            <param name="typeToExclude"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.ForAllTypes``1(System.Action{System.Type})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.IAssemblyScanner.ScanTypes(Infrastructure.Seedwork.Configuration.ITypeScanner[])">
            <summary>
            
            </summary>
            <param name="typeScanners"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.Configuration.IAssemblyScanner.Container">
            <summary>
            The IoC container that can be configured by the <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/> implementations.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Configuration.AssemblyScanner.Count">
            <summary>
            Returns the number of assemblies added to the scanner.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.ConfigureContainerTypeScanner">
            <summary>
            A <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/> that is interested in <see cref="T:Infrastructure.Seedwork.DI.IConfigureContainer"/> types.
            </summary>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1">
            <summary>
            Marker interface that can be implemented by type scanners that are interested in 
            specific types.
            </summary>
            <remarks>
            If a class is interested in scanning all <c>IHttpModule</c> implementations, it should implement
            <c>ITypeScanner&lt;IHttpModule&gt;</c>. <see cref="T:Infrastructure.Seedwork.Configuration.IAssemblyScanner">Assembly scanners</see> 
            will then call <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method for types that are assignable to
            <c>IHttpModule</c>.
            </remarks>
            <typeparam name="T">Identifies the type that the scanner is interested in.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.ITypeScanner">
            <summary>
            Interface to be implemented by classes that scan the types in an application and perform some action
            for each type of interest.
            </summary>
            <remarks>
            <p>
            A <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner">type scanner</see> may specify <see cref="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Namespace"/> and/or <see cref="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Assembly"/>
            property to filter the types it is interested in.
            </p>
            <p>
            Implementations may implement <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/> to additionally process types that are assignable
            to a specific type.
            </p>
            </remarks>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>
            <see cref="T:Infrastructure.Seedwork.Configuration.IAssemblyScanner"/>
            <see cref="T:Infrastructure.Seedwork.Configuration.TypeScannerExtentions"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)">
            <summary>
            
            </summary>
            <param name="assemblyScanner"></param>
            <param name="type"></param>
            <see cref="T:Infrastructure.Seedwork.Configuration.IAssemblyScanner"/>
        </member>
        <member name="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Namespace">
            <summary>
            Returns the namespace of the types that this scanner is interested in.
            </summary>
            <remarks>
            If the type scanner returns a non-null value for <c>Namespace</c>, an assembly scanner
            will call <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method for types that are part of the namespace 
            (<see cref="M:Infrastructure.Seedwork.Configuration.TypeExtensions.IsInNamespace(System.Type,System.String)"/>). If this property is <c>null</c>, then types
            are not filtered by namespace before calling <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Assembly">
            <summary>
            Returns the assembly of the types that this scanner is interested in.
            </summary>
            <remarks>
            If the type scanner returns a non-null value of <c>Assembly</c>, an assembly scanner
            will call <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method for types that are part of the returned assembly. If
            this property is <c>null</c>, then types are not filtered by assembly before calling
            <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method.
            </remarks>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.GenericTypeScanner`1">
            <summary>
            Generic implementation of <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/> that takes a delegate to be invoked
            for each type.
            </summary>
            <typeparam name="T"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.GenericTypeScanner`1.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)">
            <summary>
            
            </summary>
            <param name="assemblyScanner"></param>
            <param name="type"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.TypeExtensions">
            <summary>
            Extensions to <c>System.Type</c> class.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.TypeExtensions.IsInNamespace(System.Type,System.String)">
            <summary>
            Returns <c>true</c> if <paramref name="type"/> has a namespace and it starts with
            <paramref name="nameSpace"/>.
            </summary>
            <remarks>
            <p>
            Consider a <c>Customer</c> class in namespace <c>Demo.Objects</c> (i.e., <c>Demo.Objects.Customer</c>
            is the namespace qualified class name). This method returns <c>true</c> in the following scenarios:
            <br/>
            1. <c>TypeExtensions.IsInNamespace(typeof(Customer), "Demo")</c>
            <br/>
            2. <c>TypeExtensions.IsInNamespace(typeof(Customer), "Demo.Objects")</c>
            </p>
            <p>
            Note: The namespace is case sensitive, so "Demo" is different from "demo".
            </p>
            </remarks>
            <param name="type">Type to be tested.</param>
            <param name="nameSpace">Namespace to be tested.</param>
            <returns>
            <c>true</c> if the <paramref name="type"/> is part of the specified <paramref name="nameSpace"/>.
            </returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Configuration.TypeScannerExtentions">
            <summary>
            Extension methods on <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/> used by the <see cref="T:Infrastructure.Seedwork.Configuration.AssemblyScanner"/>.
            </summary>
            <author>Vamsee M Kamabathula</author>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/>
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.TypeScannerExtentions.GetPredicate(Infrastructure.Seedwork.Configuration.ITypeScanner)">
            <summary>
            Creates a predicate that filters types based on the types the scanner is interested in.
            </summary>
            <remarks>
            A type scanner can specify types of interest in the following ways:
            <list type="number">
            <item>
                <term><see cref="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Namespace"/></term>
                <description>Classes that are part of the namespace property should be passed to the 
                    <see cref="M:Infrastructure.Seedwork.Configuration.ITypeScanner.Process(Infrastructure.Seedwork.Configuration.IAssemblyScanner,System.Type)"/> method. To determine whether a type is part of a
                    namespace, <see cref="M:Infrastructure.Seedwork.Configuration.TypeExtensions.IsInNamespace(System.Type,System.String)"/> is called.
                </description>
            </item>
            <item>
                <term><see cref="P:Infrastructure.Seedwork.Configuration.ITypeScanner.Assembly"/></term>
                <description></description>
            </item>
            <item>
                <term><see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/></term>
                <description>A type scanner can implement <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/> to specify the
                specific type (and all its sub types) it is interested in.
                </description>
            </item>
            </list>
            
            <p>
            If more than one criteria (namespace, assembly and type) is specified by a type scanner, 
            then the predicate returns <c>true</c> only if the type matches each specified criteria.
            </p>
            <p>
            If a criteria is not specified (for e.g., namespace is <c>null</c>), then that criteria is ignored.
            </p>
            </remarks>
            <param name="typeScanner"></param>
            <returns>
            A predicate that filters types based on the types the <paramref name="typeScanner"/> is
            interested in.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Configuration.TypeScannerExtentions.GetTypeOfInterest(Infrastructure.Seedwork.Configuration.ITypeScanner)">
            <summary>
            Returns the type of interest to the <paramref name="typeScanner"/>.
            </summary>
            <remarks>
            <p>
            To determine the type of interest, we check if the <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner"/> implements
            <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/> and return the generic type argument. If the scanner does
            not implement <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>, this method returns <c>null</c>.
            </p>
            </remarks>
            <param name="typeScanner"></param>
            <returns>
            The type of interest to the <paramref name="typeScanner"/> or <c>null</c> if the scanner does not
            implement <see cref="T:Infrastructure.Seedwork.Configuration.ITypeScanner`1"/>.
            </returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.AbstractRepository`2">
            <summary>
            Provides concrete implementation of <see cref="T:Infrastructure.Seedwork.Data.IRepository`2"/> interface. 
            
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TIdentity"></typeparam>
            <remarks>
            <p>
            Sub classes can extend this and provide implementation of the following methods to provide 
            a concrete repository implementation:
            </p>
            <p>
            <list type="number">
            <item>
                <term>CreateQuery</term>
                <description>
                    Sub classes must provide the <c>IQueryable</c> implementation to be used by the repository.
                </description>
            </item>
            <item>
            <term>
                <c>CreateIdentitySpecification</c>
            </term>
            <description>
                Sub classes must create a specification instance given an array of key values. This is required because 
            <c>AbstractRepository</c> has no way of knowing which property of <c>TEntity</c> provides the key.
            </description>
            </item>
            </list>
            </p>
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IRepository`2">
            <summary>
            Base interface for implement a "Repository Pattern", for
            more information about this pattern see http://martinfowler.com/eaaCatalog/repository.html
            or http://blogs.msdn.com/adonet/archive/2009/06/16/using-repository-and-unit-of-work-patterns-with-entity-framework-4-0.aspx
            </summary>
            <remarks>
            Indeed, one might think that IDbSet already a generic repository and therefore
            would not need this item. Using this interface allows us to ensure PI principle
            within our domain model
            </remarks>
            <typeparam name="TEntity">Type of entity for this repository </typeparam>
            <typeparam name="TIdentity">Type of identity of the entity</typeparam>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IRepository`1">
            <summary>
            Base interface for implementing a "Repository Pattern"
            </summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`1.GetAll">
            <summary>
            Get all elements of type {TEntity} in repository
            </summary>
            <returns>List of selected elements</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`1.GetBy(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Data.SortOrder{`0})">
            <summary>
            
            </summary>
            <param name="specification"></param>
            <param name="sortOrder"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`1.GetCount(Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Returns the count of entities matching the specification.
            </summary>
            <param name="specification"></param>
            <returns>
            Count of entities matching the specification.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`1.GetPageBy(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Data.SortOrder{`0},System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="specification"></param>
            <param name="sortOrder"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`1.GetPageBy``1(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Data.SortOrder{`0},System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="TSelectProjection"></typeparam>
            <param name="specification"></param>
            <param name="sortOrder"></param>
            <param name="projection"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IRepository`1.FetchingStrategy">
            <summary>
            The strategy that a repository should consider while fetching data.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IRepository`2.Get(`1)">
            <summary>
            Get element by entity key
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.AbstractRepository`2.AllSpecification">
            <summary>
            
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.AbstractRepository`2._disposed">
            <summary>
            Flag to indicate if the repository is already disposed.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractRepository`2.#ctor">
            <summary>
            Should we take the unit of work as an argument?
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractRepository`2.CreateQuery">
            <summary>
            Sub classes must provide an <c>IQueryable&lt;<typeparamref name="TEntity"/>&gt;</c> implementation
            that is to be used by this repository for querying.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractRepository`2.CreateAllSpecification">
            <summary>
            Specification to be used to get all the entities in the repository. Sub classes can hook in to filter out
            based on access control.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractRepository`2.Validate(Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Sub classes may override this method to validate (and possible modify) a specification before it is executed.
            </summary>
            <param name="specification">The specification to be validated.</param>
            <returns>
            This method simply returns the passed in <paramref name="specification"/> without doing anything. Sub classes
            may override this method to provide appropriate validation of the specification.
            </returns>
            <remarks>
            A sub class may hook in additional criteria to the specification and return the new specification. Or it can
            validate the given specification for security and simply return the passed in <paramref name="specification"/>
            if the validation is successful. If the validation fails, then the method should throw an appropriate 
            exception.
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractRepository`2.ProcessResult(System.Collections.Generic.IList{`0})">
            <summary>
            Sub classes may override this method to process a result of query execution before it is returned to the caller.
            </summary>
            <param name="result">
            List of records returned by a query.
            </param>
            <returns>
            This method simply returns the passed in <paramref name="result"/>.
            </returns>
            <remarks>
            Note that this is only invoked when there is no select projection.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.AbstractRepository`2.IsDisposed">
            <summary>
            Returns the disposed status of this repository.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.AbstractSortKey`2">
            <summary>
            Base class that can be extended by <see cref="T:Infrastructure.Seedwork.Data.ISortKey`1"/> implementations.
            </summary>
            <remarks>
            <p>
            Sub classes need to implement only <c>IEnumerable</c> version of the <c>ApplySort</c> method
            (the <c>IQueryable</c> version internall calls the <c>IEnumerable</c> version. This is so that
            we don't break DRY in <see cref="T:Infrastructure.Seedwork.Data.ISortKey`1"/> implementations.
            </p>
            <p>
            It is perfectly acceptable for an <see cref="T:Infrastructure.Seedwork.Data.ISortKey`1"/> implementation to not
            extend this class.
            </p>
            </remarks>
            <typeparam name="TEntity">
            The type of entity for which this instance defines the sort order.
            </typeparam>
            <typeparam name="TKey"></typeparam>
            <seealso cref="T:Infrastructure.Seedwork.Data.ISortKey`1"/>
            <seealso cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ISortKey`2">
            <summary>
            SortKey interface that exposes the expression tree and expression delegate.
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TKey"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ISortKey`1">
            <summary>
            Represents the sort order of an entity by a single key.
            </summary>
            <typeparam name="TEntity">
            Identifies the entity on which the sort key is applied.
            </typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISortKey`1.ApplySort(System.Linq.IQueryable{`0})">
            <summary>
            Applies the sort on the specified queryable.
            </summary>
            <param name="query">
            The queryable on which the sort is to be applied.
            </param>
            <returns>
            The queryable after sort has been applied.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISortKey`1.ApplySort(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Applies the sort on the specified enumerable.
            </summary>
            <param name="query">
            The enumerable on which the sort is to be applied.
            </param>
            <returns>
            The enumerable after sort has been applied.
            </returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISortKey`1.Key">
            <summary>
            The key (or property) of the entity used for sorting.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISortKey`1.Descending">
            <summary>
            Returns <c>true</c> if the entity should be sorted in descending order, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISortKey`1.KeyType">
            <summary>
            Returns the type of the key.
            </summary>
            <returns>
            <c>System.Type</c> of the key represented by this sort key.
            </returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISortKey`2.KeyExpressionTree">
            <summary>
            The expression tree for generating the key.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISortKey`2.KeyExpression">
            <summary>
            <c>System.Func</c> delegate (compiled form of <see cref="P:Infrastructure.Seedwork.Data.ISortKey`2.KeyExpressionTree"/>).
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractSortKey`2.#ctor(System.String,System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Func{`0,`1})">
            <summary>
            Creates an instance of this class for the specified <paramref name="key"/>.
            </summary>
            <param name="key">
            The key (or property) of the entity used for sorting.
            </param>
            <param name="keyExpressionTree"> </param>
            <param name="keyExpression"> </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="key"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractSortKey`2.ApplySort(System.Linq.IQueryable{`0})">
            <summary>
            
            </summary>
            <param name="query">
            The queryable on which sort has to be applied. This must not be <c>null</c>.
            </param>
            <returns>
            The ordered queryable.
            </returns>
            <seealso cref="T:Infrastructure.Seedwork.Data.ISortKey`1"/>
            <seealso cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.AbstractSortKey`2.Key">
            <summary>
            The key (or property) of the entity used for sorting.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.AbstractSortKey`2.Descending">
            <summary>
            Returns <c>true</c> if the entity should be sorted in descending order, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.AbstractDbCommand">
            <summary>
            
            </summary>
            <author>Vamsee M Kambathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand">
            <summary>
            Interface to be implemented by <see cref="T:Infrastructure.Seedwork.Data.ISqlCommand"/> implementations that can be
            batched in a single call to database.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ISqlCommand">
            <summary>
            Represents an SQL script that can be executed against an NHibernate ISession.
            </summary>
            <remarks>
            Commands are not expected to return results from database (they may however have output parameters??).
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISqlCommand.Execute(System.Data.IDbCommand)">
            <summary>
            Executes the command using the specified <paramref name="dbCommand"/>.
            </summary>
            <param name="dbCommand">
            The command that needs to be executed.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.OnBeforeExecute(System.Int32,System.Data.IDbCommand)">
            <summary>
            Called by the batch command executor before executing the commands. This is where the SqlCommand
            implementation can add the parameters (required by SqlScript) to the DbCommand object.
            </summary>
            <param name="commandIndex">Index of this command in the batch.</param>
            <param name="dbCommand">The ADO.NET command object that will be used to execute the batch sql.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.OnAfterExecute(System.Int32,System.Data.IDbCommand)">
            <summary>
            Called by the batch command executor after executing the commands. This is where the SqlCommand
            implementation can extract output parameter values (if any).
            </summary>
            <param name="commandIndex">Index of this command in the batch.</param>
            <param name="dbCommand">The ADO.NET command object that will be used to execute the batch sql.</param>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.SqlScript">
            <summary>
            The script to be added to DbCommand.CommandText (after merging with other commands in the batch).
            </summary>
            <remarks>
            This property should not be accessed before <see cref="M:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.OnBeforeExecute(System.Int32,System.Data.IDbCommand)"/> is invoked. If this is
            accessed prior to <see cref="M:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.OnBeforeExecute(System.Int32,System.Data.IDbCommand)"/> being called, implementations should throw
            <see cref="T:System.InvalidOperationException"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            If this property is accessed before <see cref="M:Infrastructure.Seedwork.Data.ISupportBatchProcessingSqlCommand.OnBeforeExecute(System.Int32,System.Data.IDbCommand)"/> is invoked.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractDbCommand.OnBeforeExecute(System.Int32,System.Data.IDbCommand)">
            <summary>
            Any pre execute statments can be executed here.
            Ususally used to add some parameters/settings on to the Command Object
            </summary>
            <param name="commandIndex"></param>
            <param name="dbCommand"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractDbCommand.OnAfterExecute(System.Int32,System.Data.IDbCommand)">
            <summary>
            Post execute statements. 
            Executes after the Execute method execution is completed.
            Can be used in cases where we want to retrieve some info after the command execution.
            Stuff like reading the values from outparameters etc.
            </summary>
            <param name="commandIndex"></param>
            <param name="dbCommand"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AbstractDbCommand.PrepareDbCommand(System.Data.IDbCommand)">
            <summary>
            All the subclasses of this class can override the method to update application specific settings on the DbCommand.
            </summary>
            <param name="dbCommand"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.AbstractUnitOfWorkManager">
            <summary>
            Manages the Unit of Work over each unit of work scope.
            This is not singleton and initializes whenever a new Unit of Scope is requested
            </summary>
            <remarks>
            <p>
            Begin() begins a unit of work while End() commit/rollbacks the changes done in unit of work. 
            End() is called when unit of work scope is disposed.
            </p>
            </remarks>
            <author>Srinivas Gundu</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IManageUnitsOfWork">
            <summary>
            Interface to be implemented by classes that manage unit of work objects.
            </summary>
            <remarks>
            There is another <c>IManageUnitsOfWork</c> interface defined in NServiceBus (this interface is
            based on the NServiceBus interface).
            </remarks>
            <author>Vamsee Mohan Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IManageUnitsOfWork.Begin">
            <summary>
            Called at the begining of a unit of work operation.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IManageUnitsOfWork.End(System.Object)">
            <summary>
            Called after a unit of work operation is completed.
            </summary>
            <param name="error">
            The unhandled exception thrown after begin was called. If the work was completed successfully,
            <code>ex</code> would be <c>null</c> and the manager should call commit on each unit of work instance
            that it manages.
            </param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ADOExtensions">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.AdoUnitOfWork">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IAdoUnitOfWork">
            <summary>
            Defines the contract to be implemented by unit of work implementations that work with
            ado.net directly.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IUnitOfWork">
            <summary>
            Contract for UnitOfWork pattern
            </summary>
            <author>Vamsee Mohan Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUnitOfWork.BeginWork">
            <summary>
            Begin the work (transaction) in a container
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUnitOfWork.Commit">
            <summary>
            Commit all changes made in a container
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUnitOfWork.RollbackChanges">
            <summary>
            Rollback changes that are yet not stored in the container
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.IUnitOfWork.BeforeWrite">
            <summary>
            Event that occurs before writing changes to persistent storage.
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.IUnitOfWork.AfterWrite">
            <summary>
            Event that occurs after writing changes to persistent storage.
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.IUnitOfWork.BeforeRollback">
            <summary>
            Event that occurs before Rollback
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.IUnitOfWork.AfterRollback">
            <summary>
            Event that occurs after Rollback
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.IUnitOfWork.Disposing">
            <summary>
            Event that is fired when a unit of work is disposing.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IUnitOfWork.Key">
            <summary>
            Identifies the unit of work.
            </summary>
            <remarks>
            This is typically a connection string.
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IAdoUnitOfWork.CreateCommand">
            <summary>
            Creates a command.
            </summary>
            <remarks>
            The connection and transaction are set on the command object. Calling this method
            before begining the unit of work will result in an exception.
            </remarks>
            <returns>
            Returns a new command object initialized with connection and transaction.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <see cref="M:Infrastructure.Seedwork.Data.IUnitOfWork.BeginWork"/> was not called on this object.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IAdoUnitOfWork.CreateParameter(System.String)">
            <summary>
            Creates a parameter.
            </summary>
            <param name="paramName"></param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IAdoUnitOfWork.Factory">
            <summary>
            The factory used by this unit of work to create a connection.
            </summary>
            <remarks>
            This must never be <c>null</c>.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IAdoUnitOfWork.ConnectionString">
            <summary>
            The connection string used by this unit of work.
            </summary>
            <remarks>
            This must never be <c>null</c>.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IAdoUnitOfWork.Connection">
            <summary>
            The connection that is part of the unit of work.
            </summary>
            <remarks>
            This is available only after <see cref="M:Infrastructure.Seedwork.Data.IUnitOfWork.BeginWork"/> is invoked.
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AdoUnitOfWork.#ctor(System.Data.Common.DbProviderFactory,System.String)">
            <summary>
            Creates a unit of work that enlists into ambient transaction if available.
            </summary>
            <param name="factory">
            The provider factory to be used for creating ADO.NET objects.
            </param>
            <param name="connectionString">
            The connection string to be used.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AdoUnitOfWork.#ctor(System.Data.Common.DbProviderFactory,System.String,System.Data.IsolationLevel,System.Boolean)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="connectionString"></param>
            <param name="isolationLevel"></param>
            <param name="enlist"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AdoUnitOfWork.#ctor(Infrastructure.Seedwork.Data.IAdoUnitOfWork)">
            <summary>
            
            </summary>
            <remarks>
            <p>
            26-Aug-2013: Vamsee &amp; Phalgun:
            This will be useful for supporting a single unit of work with NServiceBus.OracleTransport.
            TODO: Write a blog post explaining this
            </p>
            </remarks>
            <param name="actualUnitOfWork"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.AdoUnitOfWork.CreateParameter(System.String)">
            <summary>
            Creates a <see cref="T:System.Data.Common.DbParameter"/> with the <paramref name="paramName"/>.
            </summary>
            <remarks>
            The parameter name will be suffixed with a ":" if ODP.NET driver is in use and 
            "@" otherwise (we assume it is SqlClient).
            </remarks>
            <param name="paramName">
            The name of the parameter. The actual parameter name will be in DbParameter.ParameterName,
            so that value should be used by the calling code instead of the passed in value. This is because
            we prefix a ":" or "@" to the paramName depending on the ADO.NET client driver.
            </param>
            <returns></returns>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.AdoUnitOfWork.BeforeRollback">
            <summary>
            
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.AdoUnitOfWork.AfterRollback">
            <summary>
            
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.Data.AdoUnitOfWork.Disposing">
            <summary>
            Event raised when the unit of work is disposing.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.AdoUnitOfWork.ConnectionString">
            <summary>
            Returns the connection string used by this unit of work.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.BatchDbCommand">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ContextUnitOfWork">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.CurrentUnitOfWorkContext">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ICurrentUnitOfWorkContext">
            <summary>
            Defines the contract for implementations which know how to scope
            the notion of an ambient unit of work.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ICurrentUnitOfWorkContext.GetCurrentUnitOfWork``1(System.String)">
            <summary>
            
            </summary>
            <typeparam name="TUnitOfWork"></typeparam>
            <param name="key"></param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ICurrentUnitOfWorkContext.Bind``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="TUnitOfWork"></typeparam>
            <param name="unitOfWork"></param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.CurrentUnitOfWorkContext.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IDataCache`2">
            <summary>
            Interface that is implemented to provide caching of data
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IDataCache">
            <summary>
            Marker Interface
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IDataCache`3">
            <summary>
            Interface that is implemented to provide caching of data with two keys
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IDataCache`4">
            <summary>
            Interface that is implemented to provide caching of data with three keys
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.Entity`1">
            <summary>
            Base class for entities
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.EntityBase">
            <summary>
            Base class for entities
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.EntityBase.IsTransient">
            <summary>
            Check if this entity is transient, i.e., without identity at this moment
            </summary>
            <returns>True if entity is transient, else false</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.EntityBase.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals"/>
            </summary>
            <param name="obj"><see cref="M:System.Object.Equals"/></param>
            <returns><see cref="M:System.Object.Equals"/></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.EntityBase.GetHashCode">
            <summary>
            <see cref="M:System.Object.GetHashCode"/>
            </summary>
            <returns><see cref="M:System.Object.GetHashCode"/></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.Entity`1.IsTransient">
            <summary>
            Check if this entity is transient, ie, without identity at this moment
            </summary>
            <returns>True if entity is transient, else false</returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.Entity`1.Id">
            <summary>
            Get the persistent object identifier
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.EntityKey">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.GenericSortKey`2">
            <summary>
            Utility class that can be used for simple sort keys instead of creating a subclass for each sort key.
            </summary>
            <typeparam name="TEntity">Entity type</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IOrderedEntity">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.IOrderedEntity.Position">
            <summary>
            Identifies the position of the entity.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IProvider`2">
            <summary>
            Interfaces to be implemented by classes that provide a value given a key.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IProvider`2.Get(`0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.OrderedEntityExtensions">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.OrderedEntityExtensions.AdjustPositions(System.Collections.Generic.IEnumerable{Infrastructure.Seedwork.Data.IOrderedEntity})">
            <summary>
            
            </summary>
            <param name="orderedEntities"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.Provider`2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.Provider`2.#ctor(System.Func{`0,`1})">
            <summary>
            
            </summary>
            <param name="resolver"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.Provider`2.Get(`0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.#ctor(System.Func{Infrastructure.Seedwork.Data.IManageUnitsOfWork,System.Boolean},System.Transactions.TransactionScopeOption)">
            <summary>
            
            </summary>
            <param name="unitOfWorkManagerFilter"></param>
            <param name="transactionScopeOption"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.#ctor(System.Func{Infrastructure.Seedwork.Data.IManageUnitsOfWork,System.Boolean},System.Transactions.TransactionScopeOption,System.Transactions.TransactionOptions)">
            <summary>
            
            </summary>
            <param name="unitOfWorkManagerFilter"></param>
            <param name="transactionScopeOption"></param>
            <param name="transactionOptions"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.UseTransactionScope">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.UnitOfWorkManagerFilter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.TransactionScopeOption">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings.TransactionOptions">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.DeterministicGuidGenerator">
            <summary>
            Utility class for converting a string value to a guid.
            </summary>
            <remarks>
            <p>
            We are evaluating if we can use NEventStore (http://neventstore.org/) for implementing
            EventSourcing in our products. However, current implementation of NEventStore uses Guid values
            for stream identity. The <see cref="M:Infrastructure.Seedwork.DeterministicGuidGenerator.ToGuid(System.String)"/> method generates the same Guid value for the
            a given string (case sensitive). And it is rare for two strings to result in the same Guid value.
            </p>
            <p>
            This implementation is based on the blog post
            (http://geekswithblogs.net/EltonStoneman/archive/2008/06/26/generating-deterministic-guids.aspx) 
            by Elton Stoneman.
            </p>
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DeterministicGuidGenerator.ToGuid(System.String)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.StringGuidExtensions">
            <summary>
            Extensions on <c>string</c> class.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.StringGuidExtensions.ToGuid(System.String)">
            <summary>
            Extension method on <see cref="T:System.String"/> to convert a string value to a guid.
            </summary>
            <param name="value">The value to be converted.</param>
            <returns>
            Returns a guid generated from the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="value"/> is an empty string.</exception>
            <seealso cref="M:Infrastructure.Seedwork.DeterministicGuidGenerator.ToGuid(System.String)"/>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IObjectPoolPopulationStrategy`1">
            <summary>
            Defines the contract to be implemented by classes that populate object pools.
            </summary>
            <typeparam name="T"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IObjectPoolPopulationStrategy`1.Bind(Infrastructure.Seedwork.DI.IObjectPool{`0})">
            <summary>
            Binds <paramref name="pool"/> to this strategy.
            </summary>
            <param name="pool">To pool to be bound.</param>
        </member>
        <member name="F:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1.MinimumCapacity">
            <summary>
            Minimum capacity of the pool.
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1._thresholdPercentage">
            <summary>
            The threshold below which the pool is repopulated.
            </summary>
            <remarks>
            <p>
            This is a value between 0 and 1. If ratio of pool.Count / capacity (i.e., the percentage of
            pool occupancy) falls below this value, then pool repopulation is triggered.
            </p>
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of population strategy.
            </summary>
            <param name="capacity">The maximum number of items to be populated in the pool at any time.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1.#ctor(System.Int32,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a new instance of this strategy.
            </summary>
            <param name="capacity">The maximum number of items to be populated in the pool at any time.</param>
            <param name="token"></param>
        </member>
        <member name="F:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1._populatingObjects">
            <summary>
            Tracks the count of parallel execution of PopulateObjects method.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.AsynchronousObjectPoolPopulationStrategy`1.PopulateObjects">
            <summary>
            Asynchronously populates the pool with new objects.
            </summary>
            <remarks>
            This method will return even before the pool is populated. 
            The pool may not be populated with new objects if the free space in the pool is less
            than the threshold.
            </remarks>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IObjectPool`1">
            <summary>
            Represents a pool of objects.
            </summary>
            <remarks>
            <p>
            In order to speed up processing of requests that require objects that are expensive to create, we use
            an object pool that contains a set of pre created objects. When a request comes in, an object is retrieved
            from the pool by calling <see cref="M:Infrastructure.Seedwork.DI.IObjectPool`1.GetObject"/> method. <see cref="M:Infrastructure.Seedwork.DI.IObjectPool`1.PutObject(`0)"/> method is used to populate
            the pool with new objects. As objects are returned by the pool, it raises the <see cref="E:Infrastructure.Seedwork.DI.IObjectPool`1.ObjectReturned"/> event
            that can be used to populate the pool with new objects. The pool itself does not care about the population
            strategy, it just holds a pool of objects and returns them in a thread safe manner.
            </p>
            </remarks>
            <typeparam name="T">The type of objects returned by the pool.</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IObjectPool`1.GetObject">
            <summary>
            Get an object from the pool.
            </summary>
            <remarks>
            If the pool is empty when this method is invoked, the pool will use a factory method to create a new
            instance of <typeparamref name="T"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            If a factory method is not set.
            </exception>
            <returns>An instance of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IObjectPool`1.PutObject(`0)">
            <summary>
            Put an object in the pool.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.DI.IObjectPool`1.Count">
            <summary>
            Returns the number of items in the pool.
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.DI.IObjectPool`1.ObjectReturned">
            <summary>
            Raised when an object is returned by <see cref="M:Infrastructure.Seedwork.DI.IObjectPool`1.GetObject"/> method.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.DI.IObjectPool`1.Factory">
            <summary>
            Returns the factory to be used for creating an instance of <typeparamref name="T"/> if the pool
            is empty.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.ObjectPool`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.ObjectPool`1.#ctor(System.Func{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="E:Infrastructure.Seedwork.DI.ObjectPool`1.ObjectReturned">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.ObjectPoolEventArgs">
            <summary>
            Contains the count of items in the pool when the ObjectReturned event is raised.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.ObjectPoolEventArgs.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:Infrastructure.Seedwork.DI.ObjectPoolEventArgs"/>
            </summary>
            <param name="itemCount">The number of items in the pool when the event is raised.</param>
        </member>
        <member name="P:Infrastructure.Seedwork.DI.ObjectPoolEventArgs.ItemCount">
            <summary>
            The number of items in the pool.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.PooledContainer">
            <summary>
            Instances of this class supporting of pooled child containers.
            </summary>
            <remarks>
            Child containers are required for each unit of work. However, creating a child container is an
            expensive operation. 
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IContainer">
            <summary>
            Interface to be implemented by Inversion of Control (IoC) containers that support child containers.
            </summary>
            <remarks>
            TODO: Define container scope and unit of work scope object definitions.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.Build(System.Type)">
            <summary>
            Builds an object of the specified type (or its sub classes or implementors if 
            <paramref name="typeToBuild"/> is an interface.
            </summary>
            <param name="typeToBuild">type of object to build</param>
            <returns>
            Object of the specified type or <c>null</c> if no matching object definition is found.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="typeToBuild"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.Build``1">
            <summary>
            Convenient method for getting the type casted object. Calling this is equivalent to calling
            <c>(TObject)Build(typeof(TObject))</c>.
            </summary>
            <typeparam name="TObject">Type of object to build.</typeparam>
            <returns>The object matching the specificed type. <c>null</c> is returned is no object
            exists matching the specified type.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.BuildAll(System.Type)">
            <summary>
            Builds all objects that match the specified <paramref name="typeToBuild"/> (i.e., 
            objects of that type, or sub clases or implementors in case the specified type is an interface).
            </summary>
            <param name="typeToBuild">
            type of object to build.
            </param>
            <returns>
            Enumerable over objects matching the specified type. If no objects match, then an empty
            enumerable is returned (i.e., this method never returns <c>null</c>).
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="typeToBuild"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.BuildAll``1">
            <summary>
            Convenient method for building objects of the specified type. Callers can also call the non-generic
            version of <c>BuildAll</c> method as well.
            </summary>
            <typeparam name="TObject">The type of objects to build.</typeparam>
            <returns>Enumerable list of objects matching the specified type. An empty enumerable is returned
            if not objects are found.</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.BuildObject(System.Object)">
            <summary>
            Injects dependencies into the supplied <paramref name="target"/> instance.
            </summary>
            <param name="target">
            The object instance that is to be so configured.
            </param>
            <returns>
            The object instance with the dependencies injected. This could be same as
            <paramref name="target"/> or a different instance altogether.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="target"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.BuildChildContainer">
            <summary>
            Builds a child container.
            </summary>
            <remarks>
            If this container is a <see cref="T:Infrastructure.Seedwork.DI.IConfigurableContainer">configurable container</see>, it
            must return child containers that are also configurable.
            </remarks>
            <returns>
            A child container. This method never returns <c>null</c>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IContainer.HasType(System.Type)">
            <summary>
            Returns <c>true</c> if the specified type is definied in this container.
            </summary>
            <param name="objectType">
            The type of object to be looked up.
            </param>
            <returns>
            <c>true</c> if the specified type is defined in this container; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="objectType"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.PooledContainer.#ctor(Infrastructure.Seedwork.DI.IContainer,Infrastructure.Seedwork.DI.IObjectPoolPopulationStrategy{Infrastructure.Seedwork.DI.IContainer})">
            <summary>
            Creates a new instance of <see cref="T:Infrastructure.Seedwork.DI.PooledContainer"/> that uses <paramref name="container"/>
            for creating new container instances.
            </summary>
            <remarks>
            The application must use this instance instead of <paramref name="container"/>.
            </remarks>
            <param name="container"></param>
            <param name="poolPopulationStrategy"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2">
            <summary>
            Classes that hold state of an aggregate root can extend this class instead of directly
            implementing <seealso cref="T:Infrastructure.Seedwork.Domain.IAggregateRootState`2"/> interface.
            </summary>
            <remarks>
            
            </remarks>
            <author>Vamsee M Kamabathula</author>
            <seealso cref="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail"/>
            <seealso cref="T:Infrastructure.Seedwork.Domain.IDomainEvent"/>
            <seealso cref="T:Infrastructure.Seedwork.Domain.IIdentity"/>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AggregateEntity`2">
            <summary>
            Base class for entities that are owned by an aggregate root.
            </summary>
            <typeparam name="TIdentity"></typeparam>
            <typeparam name="TDomainEvent"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AggregateEntity`1">
            <summary>
            Base class for aggregate entities.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRootEntity`1">
            <summary>
            Interface to be implemented by entities in an aggregate.
            </summary>
            <typeparam name="TIdentity"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AggregateEntity`1.IsTransient">
            <summary>
            Returns <c>true</c> if the entity is transient.
            </summary>
            <remarks>
            An entity is considered to be transient if it hasn't been persisted yet.
            </remarks>
            <returns>
            Returns <c>true</c> if the entity is transient; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AggregateEntity`1.ResetTransientFlag">
            <summary>
            This is called by a repository after the entity is persisted.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AggregateEntity`1.MarkTransient">
            <summary>
            Marks the entity as transient. This is required when we send the final state
            from the client and need to mark the entity as transient after deserialization.
            </summary>
            <remarks>
            Added by Vamsee on 04-Dec-2013.
            </remarks>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRootEntity`2">
            <summary>
             Interface to be implemented by entities in an aggregate.
            </summary>
            <author>Ravichand K</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRootEntity`2.Mutate(`1)">
            <summary>
            Mutates the state of child entity 
            </summary>
            <param name="event"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AggregateEntity`2.Mutate(`1)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AggregateEntity`2.RedirectToWhen(`1)">
            <summary>
            The default implementation using the dynamic dispatching of .NET. This isn't
            very efficient, so if we want performance, we should implement a more efficient
            way of dispatching the events.
            </summary>
            <remarks>
            <p>
            Sub classes may override the dispatcher by passing in a delegate in the
            <see cref="M:Infrastructure.Seedwork.Domain.AggregateEntity`2.#ctor(System.Action{System.Object,`1})">constructor</see>
            </p>
            </remarks>
            <param name="event">The event to be dispatched.</param>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AggregateEntity`2._eventDispatcher">
            <summary>
            The delegate to be used for dispatching events.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRootState`2">
            <summary>
            Contract to be implemented by classes that hold state of an aggregate root.
            </summary>
            <typeparam name="TDomainEvent">
            Base type for all events supported by the AR.
            </typeparam>
            <typeparam name="TIdentity">
            The type of the AR identity (primary key of root entity).
            </typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRootState`1">
            <summary>
            Contract to be implemented by classes that hold state of an aggregate root.
            </summary>
            <remarks>
            <p>
            <typeparamref name="TIdentity"/> should ideally be an implementation of <see cref="T:Infrastructure.Seedwork.Domain.IIdentity"/>. However,
            this is not mandatory and <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.String"/> may also be used
            as <typeparamref name="TIdentity"/>.
            </p>
            <p>
            View models that hold the aggregate root state may implement this interface.
            </p>
            </remarks>
            <typeparam name="TIdentity">The type of the aggregate root identity.</typeparam>
            <seealso cref="T:Infrastructure.Seedwork.Domain.IIdentity"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IAggregateRootState`1.Version">
            <summary>
            The current version of the aggregate state.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail">
            <summary>
            Interface to add audit trail information
            </summary>
            <author>Phalgun S Erra</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.ISupportAuditTrail.CreatedByUser">
            <summary>
            Created By User
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.ISupportAuditTrail.CreatedUtcDateTime">
            <summary>
            UTC Date Time
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.ISupportAuditTrail.ModifiedByUser">
            <summary>
            Last Modified By
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.ISupportAuditTrail.ModifiedUtcDateTime">
            <summary>
            Last Modified Date Time in UTC
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.ISupportSoftDelete">
            <summary>
            Interface to support soft deleting
            </summary>
            <author>Sowmya Bodapati</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.OnBeforeMutate(`1)">
            <summary>
            Sub classes may override this method to do some processing before the mutation
            is applied.
            </summary>
            <param name="event">The event to be applied to the state.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.OnAfterMutate(`1)">
            <summary>
            Sub classes can override this method to do some processing after the mutation
            is completed.
            </summary>
            <param name="event">The event that mutated the state.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.GetCurrentUser">
            <summary>
            Returns the current user.
            </summary>
            <remarks>
            <p>
            This is used for setting the <see cref="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.CreatedByUser"/> and <see cref="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.ModifiedByUser"/>
            properties.
            </p>
            <p>
            The default implementation uses <c>Thread.CurrentPrincipal.Identity.Name</c> for the
            current user. Sub classes may override this and provide a different implementation.
            </p>
            </remarks>
            <returns>The current user identity.</returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.Id">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.Version">
            <summary>
            The latest version of the state.
            </summary>
            <remarks>
            Version number starts with 1 and increments by 1 for every event applied on the
            state.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.CreatedByUser">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.CreatedUtcDateTime">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.ModifiedByUser">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.ModifiedUtcDateTime">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRootState`2.IsDeleted">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRootWithAudit`3">
            <summary>
            Adds <see cref="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail"/> implementation for <see cref="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3"/>
            </summary>
            <typeparam name="TIdentity">The type of aggregate identifier.</typeparam>
            <typeparam name="TEvent">The type of events raised by this aggregate.</typeparam>
            <typeparam name="TCommand">The type of commands accepted by this aggregate.</typeparam>
            <author>Phalgun S Erra</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3">
            <summary>
            Provides abstract implementation for <see cref="T:Infrastructure.Seedwork.Domain.IAggregateRoot`3"/>
            </summary>
            <remarks>
            
            </remarks>
            <typeparam name="TIdentity">The type of aggregate identifier.</typeparam>
            <typeparam name="TEvent">The type of events raised by this aggregate.</typeparam>
            <typeparam name="TCommand">The type of commands accepted by this aggregate.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRoot`3">
            <summary>
            Interface to be implemented by all aggregate roots.
            </summary>
            <typeparam name="TIdentity">Type of the aggregate id</typeparam>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TCommand"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRoot">
            <summary>
            Marker interface to be implemented by all aggregate roots.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Execute(`2)">
            <summary>
            Executes the specified command on the aggregate.
            </summary>
            <remarks>
            <p>
            An aggregate state can be changed by executing commands on it. Commands are validated
            before the aggregate can be modified. If a command is invalid, the method should throw
            an exception. If the command is valid, it is translated into one or more events which are then
            passed to the <see cref="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Apply(`1)"/> method to change the state of the aggregate.
            </p>
            <p>
            Each event generated by the command will result in the version number of the aggregate
            increasing by one. So if the current version of an aggregate is 5, and a command is executed
            on it resulting in two events, then the new version of the aggregate is 7.
            </p>
            </remarks>
            <param name="command"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Apply(`1)">
            <summary>
            Applies the event to this aggregate.
            </summary>
            <remarks>
            Apply internally calls <see cref="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Mutate(`1)"/>, however, it also tracks the changes.
            </remarks>
            <param name="event">The event to be applied.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Mutate(`1)">
            <summary>
            Mutates the state of the aggregate and increments the version of the aggregate.
            </summary>
            <seealso cref="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Apply(`1)"/>
            <param name="event">The event to be used for mutating the state.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRoot`3.ClearChanges">
            <summary>
            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Id">
            <summary>
            Unique identifier of the aggregate.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Version">
            <summary>
            The version of this aggregate.
            </summary>
            <p>
            Version number of an aggregate is incremented by 1 for every event applied on it.
            </p>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IAggregateRoot`3.Changes">
            <summary>
            Returns the list of changes done to the aggregate.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.INeedEventPublisher">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.INeedEventPublisher.EventPublisher">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3.SetEventPublisher(Infrastructure.Seedwork.Domain.IDomainEventPublisher)">
            <summary>
            
            </summary>
            <param name="eventPublisher"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3.ClearChanges">
            <summary>
            Clears the <see cref="P:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3.Changes"/> made to this aggregate.
            </summary>
            <remarks>
            This is typically called after the changes (events) are processed (or written to the event store).
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRootWithAudit`3.Apply(`1)">
            <summary>
            Applies the event to this aggregate.
            </summary>
            <remarks>
            Apply internally calls Apply of <see cref="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3"/> 
            but additionally tracks Audit trails for <see cref="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail"/>
            </remarks>
            <param name="event">The event to be applied.</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRootWithAudit`4">
            <summary>
            Adds <see cref="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail"/> implementation for <see cref="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3"/>
            </summary>
            <typeparam name="TIdentity">The type of aggregate identifier.</typeparam>
            <typeparam name="TEvent">The type of events raised by this aggregate.</typeparam>
            <typeparam name="TCommand">The type of commands accepted by this aggregate.</typeparam>
            <typeparam name="TState"></typeparam>
            <author>Phalgun S Erra</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`4">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.ISupportExternalState`1">
            <summary>
            
            </summary>
            <typeparam name="TState"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.ISupportExternalState`1.State">
            <summary>
            Returns the state of the object.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`4.Version">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractAggregateRootWithAudit`4.Apply(`2)">
            <summary>
            Applies the event to this aggregate.
            </summary>
            <remarks>
            Apply internally calls Apply of <see cref="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3"/> 
            but additionally tracks Audit trails for <see cref="T:Infrastructure.Seedwork.Domain.ISupportAuditTrail"/>
            </remarks>
            <param name="event">The event to be applied.</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractEventWithAggregateVersion`1">
            <summary>
            Interface to be implemented by <see cref="T:Infrastructure.Seedwork.Domain.IDomainEvent">domain events</see> that track the 
            aggregate root version after the event is applied on the aggregate.
            </summary>
            <remarks>
            <p>
            Check out <see cref="M:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3.Apply(`1)"/> method to see
            how this is handled.
            </p>
            </remarks>
            <typeparam name="TIdentity"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.BaseEvent`1">
            <summary>
            Abstract base class for all domain events. 
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainEvent`1">
            <summary>
            Marker interface to be implemented by aggregate events in the system.
            </summary>
            <remarks>
            <p>
            
            </p>
            </remarks>
            <typeparam name="TIdentity">Type of the root id.</typeparam>
            <seealso cref="T:Infrastructure.Seedwork.Domain.IDomainEvent"/>
            <seealso cref="T:Infrastructure.Seedwork.Domain.IAggregateRoot`3"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainEvent">
            <summary>
            Marker interface to identify events.
            </summary>
            <remarks>
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IDomainEvent.Metadata">
            <summary>
            An event can optionally have metadata associated with it.
            </summary>
            <remarks>
            <p>
            The metada could include additional information that captures the context of the event.
            </p>
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IDomainEvent.OccurredOn">
            <summary>
            Returns the date and time the event occurred (UTC).
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IDomainEvent.AggregateVersion">
            <summary>
            The version number of the aggregate after this event is applied.
            </summary>
            <remarks>
            This is typically the sequence number of the event because each event will increment the version
            number of the aggregate.
            </remarks>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IDomainEvent`1.AggregateId">
            <summary>
            Returns the unique identifier of the aggregate on which the event was applied.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.BaseEvent`1.OccurredOn">
            <summary>
            Defaults to <see cref="P:Infrastructure.Seedwork.SystemDateTime.Now"/>.ToUniversalTime().
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.INeedAggregateVersion">
            <summary>
            Events that need the aggregate version to be set on them should implement this interface.
            </summary>
            <remarks>
            See <see cref="M:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3.Apply(`1)"/> method to see how this
            is used.
            </remarks>
            <seealso cref="T:Infrastructure.Seedwork.Domain.AbstractAggregateRoot`3"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.INeedAggregateVersion.AggregateVersion">
            <summary>
            Sets the aggregate version.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractInt32Identity">
            <summary>
            Int32 Identifer Base class
            </summary>
            <author>Vamsee M Kamabathula, Phalgun S Erra</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractIdentity`1">
            <summary>
            Base implementation of <see cref="T:Infrastructure.Seedwork.Domain.IIdentity"/>, which implements
            equality and ToString once and for all.
            </summary>
            <remarks>
            </remarks>
            <typeparam name="TKey">The type of the key.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IIdentity">
            <summary>
            Marker interface for identifiers in the system.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IIdentity.GetId">
            <summary>
            Gets the id, converted to a string. Only alphanumerics and '-' are allowed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IIdentity.GetTag">
            <summary>
            Unique tag (should be unique within the assembly) to distinguish
            between different identities, while deserializing.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IIdentity.GetStableHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.GetId">
            <summary>
            Returns the identity as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.GetTag">
            <summary>
            All identity objects of the same entity type (for example Customer) will have the same tag.
            </summary>
            <remarks>
            <p>
            This is typically the entity type.
            </p>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.Equals(System.Object)">
            <summary>
            Compares if <paramref name="obj"/> represents the same entity as this identity.
            </summary>
            <param name="obj">The object to compare for equality.</param>
            <returns>
            <c>true</c> if <paramref name="obj"/> and this identity represent the same entity;
            otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.ToString">
            <summary>
            Returns the <see cref="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.GetTag"/> and <see cref="P:Infrastructure.Seedwork.Domain.AbstractIdentity`1.Id"/> concatenated with a <c>/</c> in between.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.Equals(Infrastructure.Seedwork.Domain.AbstractIdentity{`0})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.op_Equality(Infrastructure.Seedwork.Domain.AbstractIdentity{`0},Infrastructure.Seedwork.Domain.AbstractIdentity{`0})">
            <summary>
            Returns <c>true</c> if the two identities represent the same entity.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <c>true</c> if <paramref name="left"/> and <paramref name="right"/> identities 
            represent the same entity.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractIdentity`1.op_Inequality(Infrastructure.Seedwork.Domain.AbstractIdentity{`0},Infrastructure.Seedwork.Domain.AbstractIdentity{`0})">
            <summary>
            Returns <c>true</c> if the two identities are different.
            </summary>
            <param name="left">The identity on the left side of the operator.</param>
            <param name="right">The identity on the right side of the operator.</param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractIdentity`1.Id">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractInt32Identity.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractInt32Identity.Id">
            <summary>
            Integer Identity
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractInt64Identity">
            <summary>
            Int64 Identifer Base class
            </summary>
            <author>Vamsee M Kamabathula, Phalgun S Erra</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.AbstractInt64Identity.Id">
            <summary>
            Integer Identity
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractStringIdentity">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractStringIdentity.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AggregateInt32Entity`1">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AggregateInt64Entity`1">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IAggregateRootRepository`4">
            <summary>
            
            </summary>
            <typeparam name="TIdentity"></typeparam>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TCommand"></typeparam>
            <typeparam name="TAggregateRoot"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRootRepository`4.Load(`1)">
            <summary>
            
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IAggregateRootRepository`4.Save(`0)">
            <summary>
            
            </summary>
            <param name="aggregate"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractAggregateRootRepository`4">
            <summary>
            
            </summary>
            <typeparam name="TAggregateRoot"></typeparam>
            <typeparam name="TIdentity"></typeparam>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TCommand"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="F:Infrastructure.Seedwork.Domain.AbstractAggregateRootRepository`4._aggregates">
            <summary>
            Aggregate roots already loaded by this repository
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.ICreateAggregateRoot">
            <summary>
            Marker interface to be implemented by domain events that create an aggregate root.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.DefaultTypeNameResolver">
            <summary>
            Provides implementation for <see cref="T:Infrastructure.Seedwork.Domain.ITypeNameResolver"/>
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.ITypeNameResolver">
            <summary>
            Contract for resolving types based on type name. 
            </summary>
            <remarks>
            Events are persisted into eventstore without fully qualified type information. 
            This is done to eliminate coupling with specific event types.
            <see cref="T:Infrastructure.Seedwork.Domain.ITypeNameResolver"/> helps in resolving event types based on type name.</remarks>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.ITypeNameResolver.Register(System.Type)">
            <summary>
            Registers a type with the <see cref="T:Infrastructure.Seedwork.Domain.ITypeNameResolver"/>
            </summary>
            <param name="type"><see cref="T:System.Type"/> to be registered with resolver</param>
            <exception cref="T:System.Data.DuplicateNameException">
            Thrown if <paramref name="type"/> is already registered with resolver.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.ITypeNameResolver.Resolve(System.String)">
            <summary>
            Resolves <see cref="T:System.Type"/> based on given <paramref name="typeName"/>
            </summary>
            <param name="typeName">Name of type to be resolved</param>
            <returns><see cref="T:System.Type"/> that matches given <paramref name="typeName"/></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainRepository`2">
            <summary>
            Base Repository Interface to persist Domain Aggregates
            </summary>
            <typeparam name="TAggregate">Aggregate root</typeparam>
            <typeparam name="TIdentity">Identity</typeparam>
            <author>Phalgun S Erra</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IDomainRepository`2.Get(`1)">
            <summary>
            Returns the latest version of the aggregate.
            </summary>
            <param name="id">Identifies the aggregate.</param>
            <returns>
            The latest version of the aggregate or <c>null</c> if no 
            aggregate with specified <paramref name="id"/> exists in the repository.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IDomainRepository`2.Save(`0)">
            <summary>
            Saves the aggregate.
            </summary>
            <param name="aggregate">Aggregate to Save</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IEventSourcedRepository`3">
            <summary>
            Interface to be implemented by repositories that support event sourcing.
            </summary>
            <typeparam name="TAggregate">Type of the aggregate.</typeparam>
            <typeparam name="TIdentity">Type of aggregate identity.</typeparam>
            <typeparam name="TEvent">Base type of the events applicable to the aggregate.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IEventSourcedRepository`3.Get(`1)">
            <summary>
            Returns the latest version of the aggregate snapshot.
            </summary>
            <param name="identity">Identifies the aggregate.</param>
            <returns>
            The latest version of the aggregate snapshot or <c>null</c> if no 
            aggregate with specified <paramref name="identity"/> exists in the repository.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IEventSourcedRepository`3.Get(`1,System.Int32)">
            <summary>
            Returns the specified version of the aggregate snapshot.
            </summary>
            <param name="identity">Identifies the aggregate.</param>
            <param name="version">The version of the aggregate snapshot to return.</param>
            <returns>
            The specified version of the aggregate snapshot or <c>null</c> if no
            aggregate with specified <paramref name="identity"/> exists in the repository.
            </returns>
            <exception cref="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException">
            Thrown if <paramref name="version"/> is greater than the maximum version number of the
            aggregate.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IEventSourcedRepository`3.Save(`1,System.Int32,System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Saves a collection of events to an aggregate.
            </summary>
            <remarks>
            <p>
            If <paramref name="events"/> is <c>null</c> or empty, this method must return without doing anything.
            No exception must be thrown.
            </p>
            <p>
            If no aggregate exists with the specified identity, then the repository should implicitly
            create an aggregate and append the events to it.
            </p>
            </remarks>
            <param name="identity">Identifies the aggregate to which the events apply.</param>
            <param name="version">The version of the aggregate to which the events are to be applied.</param>
            <param name="events">The events to be applied.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IEventSourcedRepository`3.GetEvents(`1,System.Int32,System.Int32)">
            <summary>
            Returns the events of an aggregate from <paramref name="fromVersion"/> to <paramref name="toVersion"/>
            (both inclusive).
            </summary>
            <param name="identity">Identifies the aggregate whose events are to be returned.</param>
            <param name="fromVersion">The version from which to get the events.</param>
            <param name="toVersion">The version upto which the events must be retrieved.
            Set this to <see cref="F:Infrastructure.Seedwork.Domain.EventVersion.Latest"/> to get all events from <paramref name="fromVersion"/>.
            </param>
            <returns>
            Events of an aggregate (with specified <paramref name="identity"/>) between <paramref name="fromVersion"/>
            and <paramref name="toVersion"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="fromVersion"/> is less than <c>1</c> or if <paramref name="toVersion"/>
            is less than <paramref name="fromVersion"/>.
            </exception>
            <seealso cref="T:Infrastructure.Seedwork.Domain.EventVersion"/>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IFetchingStrategy`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            
            </summary>
            <typeparam name="TRelated"></typeparam>
            <param name="relatedEntity"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IMaterializedViewWriter">
            <summary>
            Marker interface for materialized view writers
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IMaterializedViewWriter`2">
            <summary>
            Interface to be implemented by materialized view writers that store a view of an aggregate.
            </summary>
            <remarks>
            A materialized view write consumes domain events and constructs views for a specific aggregate type.
            Each repository generates one and only one view of the system.
            </remarks>
            <typeparam name="TIdentity">Type of identity of the aggregate whose view 
            is generated by this repository.</typeparam>
            <typeparam name="TEvent">Base type of events accepted by this repository.</typeparam>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IMaterializedViewWriter`2.Update(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Updates the view identified by <paramref name="identity"/> with the specified 
            <paramref name="events"/>.
            </summary>
            <param name="identity">
            Identifies the aggregate whose view should be updated.
            </param>
            <param name="events">
            The events to be applied to the aggregate.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IMaterializedViewWriter`2.Update(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Updates the view with the specified <paramref name="events"/>.
            </summary>
            <param name="events">
            The events to be applied to the materialized view.
            </param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IViewReader">
            <summary>
            Marker interface for view readers
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IViewReader`2">
            <summary>
            Interface to be implemented by view readers that read a view of an aggregate.
            </summary>
            <remarks>
            A materialized view reader reads view of an aggregate.
            </remarks>
            <typeparam name="TView">Type of view read by this view reader.</typeparam>
            <typeparam name="TIdentity">Type of identity of the aggregate whose view 
            is to be read by this repository.</typeparam>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IViewReader`2.Get(`1)">
            <summary>
            Returns the view of the aggregate identified by <paramref name="identity"/>.
            </summary>
            <param name="identity">
            Identifies the aggregate whose view is to be returned.
            </param>
            <returns>
            The view of the aggregate identified by <paramref name="identity"/>. If no view exists
            corresponding to <paramref name="identity"/>, then <c>null</c> must be returned.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IViewReader`2.GetPageOf(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Data.SortOrder{`0},System.Int32,System.Int32)">
            <summary>
            Returns a page of views that match <paramref name="specification"/> ordered by 
            <paramref name="sortOrder"/>.
            </summary>
            <param name="specification">The criteria to be used for filtering the views.</param>
            <param name="sortOrder">The order in which to sort the views</param>
            <param name="start">Zero based index of the item from which to fetch data.</param>
            <param name="count">The number of items to fetch.</param>
            <returns>
            Page of views matching <paramref name="specification"/> ordered by <paramref name="sortOrder"/>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IQueryableRepository`1.GetFiltered(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Get elements of type TEntity in repository
            </summary>
            <param name="filter">Filter that each element do match</param>
            <returns>List of selected elements</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IQueryableRepository`1.AllMatching(Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Get all elements of type TEntity that matching a
            Specification <paramref name="specification"/>
            </summary>
            <param name="specification">Specification that result meet</param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IQueryableRepository`1.GetPaged``1(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Get all elements of type TEntity in repository
            </summary>
            <param name="pageIndex">Page index</param>
            <param name="pageCount">Number of elements in each page</param>
            <param name="orderByExpression">Order by expression for this query</param>
            <param name="ascending">Specify if order is ascending</param>
            <returns>List of selected elements</returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IUnitOfWorkScopeAction">
            <summary>
            Interface to be implemented by classes that execute in the context of a unit of work scope.
            </summary>
            <remarks>
            
            </remarks>
            <seealso cref="T:Infrastructure.Seedwork.Data.UnitOfWorkScope"/>
            <seealso cref="!:UnitOfWorkScope.ExecuteUnitOfWork(IContainer,IUnitOfWorkScopeAction)"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUnitOfWorkScopeAction.Execute">
            <summary>
            Executes the action represented by this instance.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.IUpdateableRepository`2">
            <summary>
            Interface to be implemented by repositories that can be updated.
            </summary>
            <typeparam name="TEntity">Type of entity.</typeparam>
            <typeparam name="TIdentity">Type of the entity key.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUpdateableRepository`2.Add(`0)">
            <summary>
            Add item into repository
            </summary>
            <param name="item">Item to add to repository</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUpdateableRepository`2.Remove(`0)">
            <summary>
            Delete item 
            </summary>
            <param name="item">Item to delete</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUpdateableRepository`2.Update(`0)">
            <summary>
            Update item into repository
            </summary>
            <param name="item">Item to update in repository</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.IUpdateableRepository`2.New">
            <summary>
            Returns new instance of the specified entity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.SortableEntityKey`5">
            <summary>
            
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TKey3"></typeparam>
            <typeparam name="TKey4"></typeparam>
            <typeparam name="TKey5"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.SortOrder`1">
            <summary>
            Instances of this class encapsulate the sort order to be done on the specified entity.
            </summary>
            <typeparam name="TEntity">
            The type of entity for which this instance defines the sort order.
            </typeparam>
            <remarks>
            A <c>SortOrder</c> instance must have atleast one key, else it is considered to be invalid and the
            sort order cannot be applied on an enumerable or queryable.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrder`1.#ctor(Infrastructure.Seedwork.Data.ISortKey{`0}[])">
            <summary>
            Create a sort order instance with the specified <see cref="T:Infrastructure.Seedwork.Data.ISortKey`1">keys</see>.
            </summary>
            <param name="sortKeys">
            The keys that define the sort order.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrder`1.IsValid">
            <summary>
            A <c>SortOrder</c> instance is considered to be valid if it has atleast one key specified.
            </summary>
            <returns>
            <c>true</c> if the sort order has atleast one key, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrder`1.ApplySort(System.Linq.IQueryable{`0})">
            <summary>
            Applies the sort on the specified queryable.
            </summary>
            <param name="query">
            The query on which sort order should be applied.
            </param>
            <returns>
            The queryable after sort order has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="query"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1">Keys</see> is <c>null</c>
            or empty (<c>Length</c> is <c>0</c>).
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrder`1.ApplySort(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Applies the sort on the specified enumerable.
            </summary>
            <param name="query">
            The enumerable on which sort has to be applied.
            </param>
            <returns>
            The enumerable after sort order has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="query"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If <see cref="P:Infrastructure.Seedwork.Data.SortOrder.Keys">Keys</see> is <c>null</c>
            or empty (<c>Length</c> is <c>0</c>).
            </exception>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.SortOrder`1.Keys">
            <summary>
            Gets the <see cref="T:Infrastructure.Seedwork.Data.ISortKey`1">keys</see> used for sorting the 
            <typeparamref name="TEntity">entity</typeparamref>.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.SortOrderExtensions">
            <summary>
            Provides extention methods on IQueryable and IEnumerable that apply a 
            <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/> on them.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrderExtensions.OrderBy``1(System.Linq.IQueryable{``0},Infrastructure.Seedwork.Data.SortOrder{``0})">
            <summary>
            Applies the <paramref name="sortOrder"/> on the given <paramref name="query"/>.
            </summary>
            <typeparam name="TEntity">Type of entity.</typeparam>
            <param name="query">Queryable on which sort is to be applied.</param>
            <param name="sortOrder">
            The <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1">sort order</see> to be applied.
            </param>
            <returns>
            The ordered query.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrderExtensions.OrderBy``1(System.Collections.Generic.IEnumerable{``0},Infrastructure.Seedwork.Data.SortOrder{``0})">
            <summary>
            Applies the <paramref name="sortOrder"/> on the given <paramref name="query"/>.
            </summary>
            <typeparam name="TEntity">Type of entity.</typeparam>
            <param name="query">Enumerable on which sort is to be applied.</param>
            <param name="sortOrder">
            The <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1">sort order</see> to be applied.
            </param>
            <returns>
            The ordered query.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrderExtensions.GetKeyTypes``1(Infrastructure.Seedwork.Data.SortOrder{``0})">
            <summary>
            Returns the <c>System.Type</c> objects for the keys in the <paramref name="sortOrder"/>.
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="sortOrder"></param>
            <returns>Array of types containing type of keys (the sequence of types match the sequence of keys).</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.SortOrderExtensions.Descending``2(Infrastructure.Seedwork.Data.ISortKey{``0,``1})">
            <summary>
            
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="sortKey"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.UnitOfWorkScope">
            <summary>
            Instances of this class manage the scope for executing a unit of work.
            </summary>
            <remarks>
            <p>
            Executing a unit of work typically involve the following actions:
            <list type="number">
            <item>
            <term>Manage an IContainer</term>
            <description>
            To execute code in a unit of work, we need to create a child container that creates objects required
            for executing the work.
            </description>
            </item>
            <item>
            <term>Manage a TransactionScope</term>
            <description>
            The unit of work must execute in a transaction scope so that if an error occurs, the incomplete work
            is rolled back.
            </description>
            </item>
            <item>
            <term>Persist changes</term>
            <description>
            The new generation ORM (object relational mapping) tools like <c>NHibernate</c>, <c>Entity Framework</c>, etc
            track object changes in memory. So before a transaction scope can be completed, the in memory changes must be
            flushed to disk. This is the responsibility of <see cref="T:Infrastructure.Seedwork.Data.IManageUnitsOfWork"/> instances. At the begining of
            some work, we must create instances of <see cref="T:Infrastructure.Seedwork.Data.IManageUnitsOfWork"/> registered in the child <see cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            and call <see cref="M:Infrastructure.Seedwork.Data.IManageUnitsOfWork.Begin"/>. At the end of the work, before calling <see cref="M:System.Transactions.TransactionScope.Complete"/>,
            we must call <see cref="M:Infrastructure.Seedwork.Data.IManageUnitsOfWork.End(System.Object)"/> so that the in memory changes are flushed to disk.
            </description>
            </item>
            </list>
            <br/>
            Repeating the above steps every time we need to do a unit of work (which is like all the time in a business application
            as everything is a unit of work) is very cumbersome and breaks <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> 
            (don't repeat yourself) principle.
            <br/>
            <c>UnitOfWorkScope</c> tries to solve this problem by managing the above three aspects of executing code in a unit
            of work.
            </p>
            </remarks>
            <example>
            The following code demonstrates how a <c>UnitOfWorkScope</c> simplifies execution of a unit of work:
            <code>
            using(var uowScope = new UnitOfWorkScope(rootContainer)){
                var childContainer = uowScope.Container;
                var customerService = childContainer.Build&lt;ICustomerService&gt;();
                customerService.RegisterCustomer(customer);
                var orderService = childContainer.Build&lt;IOrderService&gt;();
                orderService.PlaceOrder(customer.Id, order);
            
                uowScope.Complete();
            }
            </code>
            <br/>
            The following code demonstrates how a <see cref="T:Infrastructure.Seedwork.Data.IUnitOfWorkScopeAction"/> can be used even more elegantly:
            <code>
            public class RegisterCustomerAndPlaceOrderAction : IUnitOfWorkScopeAction{
                private Customer _customer;
                private Order _order;
            
                public RegisterCustomerAndPlaceOrderAction(Customer customerToBeRegistered, Order orderToBePlaced){
                    _customer = customerToBeRegistered;
                    _order = orderToBePlaced;
                }
            
                public void Init(){
                    if(CustomerService == null){
                        throw new InvalidOperationException("CustomerService is not set");
                    }
                    if(OrderService == null){
                        throw new InvalidOperationException("OrderService is not set");
                    }
                }
            
                public ICustomerService CustomerService{ get; set; }
            
                public IOrderService OrderService {get; set; }
            
                void IUnitOfWorkScopeAction.Execute(){
                    Init();
            
                    CustomerService.RegisterCustomer(_customer);
                    OrderService.PlaceOrder(_customer.Id, _order);
                }
            }
            
            UnitOfWorkScope.ExecuteUnitOfWork(rootContainer, new RegisterCustomerAndPlaceOrderAction(customer, order));
            </code>
            </example>
            <seealso cref="T:Infrastructure.Seedwork.Data.IUnitOfWorkScopeAction"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.Data.IManageUnitsOfWork"/>
            <seealso cref="T:System.Transactions.TransactionScope"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.UnitOfWorkScope._isCompleted">
            <summary>
            Set to <c>true</c> when <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/> is called on this instance.
            </summary>
            <remarks>
            If this is <c>false</c>, then the transaction scope of this instance is rolled back.
            </remarks>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.UnitOfWorkScope._error">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.#ctor(Infrastructure.Seedwork.DI.IContainer,Infrastructure.Seedwork.Data.UnitOfWorkScopeSettings)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete">
            <summary>
            Marks the unit of work as complete.
            </summary>
            <remarks>
            <p>
            If a unit of work scope is marked as complete, the transaction in which the work is executed will be marked as 
            complete. Conversely, if a unit of work scope is disposed without calling complete, then the transaction is 
            rolled back.
            </p>
            <p>
            <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Dispose">Disposing</see> a scope without calling <c>Complete</c> will result in the transaction
            being rolled back.
            </p>
            </remarks>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.SetError(System.Exception)">
            <summary>
            If an unhandled exception is thrown during processing of a unit of work, it can be set on the unit of work scope
            to indicate that the unit of work should be rolled back.
            </summary>
            <remarks>
            <p>
            Once an error is set on an instance, it cannot be marked as <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/>. 
            Conversely, once an instance is marked as <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/>, error cannot be set.
            </p>
            <p>
            Even if an error is not set on an instance, the transaction will still be rolledback at the time of disposal
            if <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/> was not called. Setting the error just helps in debugging and is not a mandatory 
            requirement.
            </p>
            </remarks>
            <param name="error">
            The error to be set.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="error"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If <see cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/> was already called on this instance.
            </exception>
            <seealso cref="M:Infrastructure.Seedwork.Data.UnitOfWorkScope.Complete"/>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScope.Settings">
            <summary>
            The settings used for creating the scope.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScope.Container">
            <summary>
            The container used for creating objects in the scope.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.UnitOfWorkScope.DefaultSettings">
            <summary>
            The default settings to be used in case no settings were specified in the constructor.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ValueObject`1">
            <summary>
            Base class for value objects in domain.
            </summary>
            <typeparam name="TValueObject">The type of this value object</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ValueObject`1.Equals(`0)">
            <summary>
            <see cref="M:System.Object.IEquatable{TValueObject}"/>
            </summary>
            <param name="other"><see cref="M:System.Object.IEquatable{TValueObject}"/></param>
            <returns><see cref="M:System.Object.IEquatable{TValueObject}"/></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ValueObject`1.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals"/>
            </summary>
            <param name="obj"><see cref="M:System.Object.Equals"/></param>
            <returns><see cref="M:System.Object.Equals"/></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ValueObject`1.GetHashCode">
            <summary>
            <see cref="M:System.Object.GetHashCode"/>
            </summary>
            <returns><see cref="M:System.Object.GetHashCode"/></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IConfigurableContainer">
            <summary>
            Interface to be exposed by containers that can be configured programatically.
            </summary>
            <remarks>
            <p>
            IoC containers like Spring.NET support configuration through XML files. However,
            doing the complete configuration by XML files would be very difficult to manage as it would
            be too verbose and the XML files would have to be copied to different application modules
            or components (like reporting, web app, tools, integrator, etc).
            </p>
            <p>
            In addition, there is really no value add to having the XML file files if we are not
            passing in any application settings through the configuration. Take the classic example of
            unit of work and repository patterns. A repository needs a unit of work object and unit of work
            object is some pre defined class defined in the infrastructure implementation. There is no
            point in wiring these types using XML. In such scenarios, we are better off configuring the
            objects using code instead of XML files.
            </p>
            <p>
            <c>IConfigurableContainer</c> implementations allow us to configure a container from code, thus
            reducing duplicated configuration across application modules / components.
            </p>
            <p>
            A container is configurable only if it hasn't been used to build objects. If either of the
            build methods (<see cref="M:Infrastructure.Seedwork.DI.IContainer.Build(System.Type)">Build</see>, <see cref="M:Infrastructure.Seedwork.DI.IContainer.BuildAll(System.Type)">BuildAll</see>
            and <see cref="M:Infrastructure.Seedwork.DI.IContainer.BuildChildContainer">BuildChildContainer</see>) is called on a container,
            it is initialized. After the initialization is done, calling any methods defined by this interface
            should result in <c>System.InvalidOperationException</c> being thrown.
            </p>
            </remarks>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IConfigureContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainerAware"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigurableContainer.RegisterSingleton(System.Type,System.Object)">
            <summary>
            Registers the specified instance as a singleton.
            </summary>
            <remarks>
            A container that is initialized cannot be modified. So calling this method after the container
            is initialized will result in an exception being thrown.
            </remarks>
            <param name="lookupType">
            The type that should be mapped to the singleton instance.
            </param>
            <param name="instance">
            The singleton instance.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If the container is initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigurableContainer.RegisterType(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Registers a type with the container.
            </summary>
            <param name="objectType">
            The type whose instances are to be created by this container.
            </param>
            <param name="singleton">
            <c>true</c> if the type should be treated as a singleton.
            </param>
            <param name="unitOfWorkScope">
            <c>true</c> if the type should be registered in the unit of work scope.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If the container is initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigurableContainer.RegisterType``1(System.Func{Infrastructure.Seedwork.DI.IContainer,``0},System.Boolean,System.Boolean)">
            <summary>
            Registers a type that is instantiated by a factory method instead of of the container. The container
            however will still inject the dependencies into the object returned by the factory method.
            </summary>
            <typeparam name="T">The type of object to be registered.</typeparam>
            <param name="factoryMethod">
            Delegate that creates an instance of type <typeparamref name="T"/>. The container instance is passed to the
            delegate and the delegate is free to use the container to create other objects that are needed to initialize
            the instance of <typeparamref name="T"/>.
            </param>
            <param name="singleton">
            <c>true</c> will result in the type being treated as a singleton object.
            </param>
            <param name="unitOfWorkScope"><c>true</c> will result in the type being reg
            <c>true</c> if the type should be registered in the unit of work scope.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigurableContainer.ConfigureType(System.Type,System.String,System.Object)">
            <summary>
            This is used to programatically set property values on types that are defined in the container.
            </summary>
            <remarks>
            <p>
            Once a type is registered in the container (programatically using <c>RegisterType</c> or through
            XML configuration), we can use <c>ConfigureType</c> method to define property values.
            </p>
            </remarks>
            <param name="objectType">
            The object type whose property should be configured. This must not be <c>null</c>.
            </param>
            <param name="property">Name of the property. This must not be <c>null</c>.
            Note that we don't validate if the property name is valid for the specified type.
            </param>
            <param name="value">Value of the property. This may be <c>null</c>.</param>
            <exception cref="T:System.InvalidOperationException">
            If the container is already initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigurableContainer.ConfigureType``2(System.String,System.Func{``1,System.Object})">
            <summary>
            Configures a property on <typeparamref name="TObjectType"/> by assigning it the value derived from
            an instance of <typeparamref name="TSourceType"/>.
            </summary>
            <typeparam name="TObjectType">The type of object whose property is to be configured.</typeparam>
            <typeparam name="TSourceType">The type of object which provides the</typeparam>
            <param name="propertyName">Name of the property on <typeparamref name="TObjectType"/>.</param>
            <param name="valueExpression">Delegate that returns the value to be assigned to the property
            of <typeparamref name="TObjectType"/> given an instance of <typeparamref name="TSourceType"/>.</param>
        </member>
        <member name="T:Infrastructure.Seedwork.DI.IConfigureContainer">
            <summary>
            Classes that configure a container should implement this interface.
            </summary>
            <remarks>
            <p>
            We can automate the container configuration by looking up all the classes that
            implement this interface and then invoking the <c>Configure</c> method on an instance
            of each type.
            </p>
            <p>
            For this to work properly, classes implementing this interface should have not have constructors
            with parameters. The best thing is to no have a constructor at all.
            </p>
            </remarks>
            <seealso cref="T:Infrastructure.Seedwork.DI.IContainer"/>
            <seealso cref="T:Infrastructure.Seedwork.DI.IConfigurableContainer"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.DI.IConfigureContainer.Configure(Infrastructure.Seedwork.DI.IConfigurableContainer)">
            <summary>
            Configures the specified container with object definitions.
            </summary>
            <param name="container">
            The container to be configured. This must not be <c>null</c>.
            </param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractBoundedContext">
            <summary>
            Base classes for bounded contexts.
            </summary>
            <remarks>
            
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IBoundedContext">
            <summary>
            Provides contract for Bounded Contexts to be implemented.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Configure(Infrastructure.Seedwork.Domain.BoundedContextProfile,System.String)">
            <summary>
            Configures the bounded context.
            </summary>
            <param name="profile"></param>
            <param name="applicationBaseDirectory"></param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the bounded context is already initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Initialize">
            <summary>
            Initializes the bounded context. Bounded context must be configured before initialization.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the bounded context is already initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Shutdown">
            <summary>
            Releases all the resources in the context.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute``1(System.Action{``0})">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <typeparam name="T">dependency type to be injection</typeparam>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute``2(System.Action{``0,``1})">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <typeparam name="T1">dependency type to be injected</typeparam>
            <typeparam name="T2">dependency type to be injected</typeparam>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute``3(System.Action{``0,``1,``2})">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <typeparam name="T1">dependency type to be injected</typeparam>
            <typeparam name="T2">dependency type to be injected</typeparam>
            <typeparam name="T3">dependency type to be injected</typeparam>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute``4(System.Action{``0,``1,``2,``3})">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <typeparam name="T1">dependency type to be injected</typeparam>
            <typeparam name="T2">dependency type to be injected</typeparam>
            <typeparam name="T3">dependency type to be injected</typeparam>
            <typeparam name="T4">dependency type to be injected</typeparam>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute``5(System.Action{``0,``1,``2,``3,``4})">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <typeparam name="T1">dependency type to be injected</typeparam>
            <typeparam name="T2">dependency type to be injected</typeparam>
            <typeparam name="T3">dependency type to be injected</typeparam>
            <typeparam name="T4">dependency type to be injected</typeparam>
            <typeparam name="T5">dependency type to be injected</typeparam>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IBoundedContext.Execute(Infrastructure.Seedwork.Data.IUnitOfWorkScopeAction)">
            <summary>
            Executes an action in the scope of a bounded context.
            </summary>
            <param name="action"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IBoundedContext.Name">
            <summary>
            Name of the bounded context.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IBoundedContext.IsInitialized">
            <summary>
            Returns <c>true</c> if the context is initialized.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IBoundedContext.Container">
            <summary>
            Returns the root container of the context.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IBoundedContext.Profile">
            <summary>
            The profile specified during initialization.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is accessed before the context is initialized.
            </exception>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.AbstractBoundedContext.ConfigureScanner(Infrastructure.Seedwork.Configuration.IAssemblyScanner)">
            <summary>
            
            </summary>
            <param name="scanner"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.BoundedContextProfile">
            <summary>
            Specifies the environment in which BoundedContext has been utilized.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.EventVersion">
            <summary>
            Defines the constants to be used for specifying special version numbers.
            </summary>
            <author>Vamsee M Kamabathula</author>
            <seealso cref="T:Infrastructure.Seedwork.Data.IEventSourcedRepository`3"/>
        </member>
        <member name="F:Infrastructure.Seedwork.Domain.EventVersion.Any">
            <summary>
            Indicates to an event sourced repository that the client is not particular a specific version.
            The repository can assume any version that makes sense.
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Domain.EventVersion.Latest">
            <summary>
            Indicates to an event sourced repository that the client is interested in the latest version
            of an aggregate (but doesn't know what is the latest version).
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainCommand">
            <summary>
            Marker interface for commands in the system.
            </summary>
            <remarks>
            <see cref="T:Infrastructure.Seedwork.Domain.IDomainCommand"/> would represent commands that get translated to <see cref="T:Infrastructure.Seedwork.Domain.IDomainEvent"/>.
            And is differnet from <see cref="T:Infrastructure.Seedwork.Messaging.ICommand"/> as <see cref="T:Infrastructure.Seedwork.Domain.IDomainCommand"/>.Id might not 
            always be of type <see cref="T:System.Guid"/>.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainCommand`1">
            <summary>
            Marker Interface for all Aggregate Commands that change the state
            of the Aggregate
            </summary>
            <typeparam name="TIdentity"></typeparam>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.IDomainCommand`1.AggregateId">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDomainEventPublisher">
            <summary>
            Publishes events that are occured in the Domain.
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IDomainEventPublisher.Publish(System.Object,Infrastructure.Seedwork.Domain.IDomainEvent)">
            <summary>
            Publishes domain event to all listeners
            </summary>
            <param name="source">Component that raised a domain event</param>
            <param name="event">Domain event to be published</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractDomainEvent">
            <summary>
            Base class for domain events.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.AbstractDomainEvent`1">
            <summary>
            Base class for domain events that track the aggregate root (AR) identity.
            </summary>
            <typeparam name="TIdentity">The type of the AR identity.</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.INeedAggregateId">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.INeedAggregateId.SetAggregateId(Infrastructure.Seedwork.Domain.IIdentity)">
            <summary>
            
            </summary>
            <param name="aggregateId"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.ISequenceGenerator">
            <summary>
            Providers contract for components that generate unique identity for given SequenceName.
            </summary>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISequenceGenerator.GetNextInt32Value(System.String)">
            <summary>
            Generates an Int32 value
            </summary>
            <param name="sequenceName">Entity Name for which the Int32 identifier has to be generated</param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISequenceGenerator.GetNextInt64Value(System.String)">
            <summary>
            Generates an Int64 identifier
            </summary>
            <param name="sequenceName">Entity Name for which the Int64 identifier has to be generated</param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISequenceGenerator.GetNextInt32Values(System.String,System.Int32)">
            <summary>
            Generates a chunk of Int32 identifiers
            </summary>
            <param name="sequenceName">Entity Name for which the Int32 identifier has to be generated</param>
            <param name="numberOfIds">Number of Ids to generate</param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.ISequenceGenerator.GetNextInt64Values(System.String,System.Int32)">
            <summary>
            Generates a chunk of Int64 identifiers
            </summary>
            <param name="sequenceName">Entity Name for which the Int32 identifier has to be generated</param>
            <param name="numberOfIds">Number of Ids to generate</param>
            <returns></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.ISequenceGenerator.MissingSequenceAction">
            <summary>
            Action to be performed if the specified sequence doesn't exist
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IHandleDomainEvent`1">
            <summary>
            Provides contract for Domain Event Handlers.
            </summary>
            <typeparam name="TEvent"></typeparam>
            <author>Murlai Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IHandleDomainEvent`1.Handle(`0)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IHandleDomainEvent`1.Handle(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Supports bulk handling of events.
            </summary>
            <param name="events"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.INeedContextProfile">
            <summary>
            Indicates that the component which implements <see cref="T:Infrastructure.Seedwork.Domain.INeedContextProfile"/> requires <see cref="T:Infrastructure.Seedwork.Domain.BoundedContextProfile"/> to be set.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.INeedContextProfile.Profile">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.INeedSequenceGenerator">
            <summary>
            Interface to be implemented by aggregate roots that need to generate identity values
            for child entities.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.INeedSequenceGenerator.SequenceGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IDeleteAggregateRoot">
            <summary>
            Marker interface to be implemented by domain events that soft delete an aggregate root.
            This interface is only for soft delete which is used to set IsDeleted property to true.
            </summary>
            <author>Sowmya Bodapati</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.IProvideSnapshot`4">
            <summary>
            Contract for providing snapshot to Aggregates.
            </summary>
            <typeparam name="TAggregate">Aggregate for which snapshot has to be captured/retrieved</typeparam>
            <typeparam name="TIdentity">Identity of Aggregate for which snapshot to be provided</typeparam>
            <typeparam name="TEvent">Type of events that helped Aggregate state to be prepared</typeparam>
            <typeparam name="TCommand">Type of commands that are executed on Aggregate instance</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IProvideSnapshot`4.Get(`1,System.Int32)">
            <summary>
            Retrieves Aggregate instance from snapshot persisted into eventstore 
            </summary>
            <param name="id">Identity of Aggregate to be retrieved </param>
            <param name="version">Aggregate version to be retrieved</param>
            <returns>Aggregate instance with given identity and version</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.IProvideSnapshot`4.CaptureSnapshot(`1)">
            <summary>
            Captures Snapshot for Aggregate instance with given identity
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.NullEventPublisher">
            <summary>
            Dummy event publisher 
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.NullEventPublisher.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.TableBasedSequenceGenerator">
            <summary>
            Sequence Id Generator that generates next sequence for an entity from the database
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGenerator.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a sequence generator instance. Throws an error if this sequence generator is used on a sequence that doesn't exist. 
            </summary>
            <param name="connectionString"></param>
            <param name="provider"></param>
            <param name="tableName"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGenerator.#ctor(System.String,System.String,System.String,Infrastructure.Seedwork.Data.MissingSequenceAction)">
            <summary>
            Creates a sequence generator instance. Performs the specified action if the sequence generator is used on a sequence that doesn't exist.
            </summary>
            <param name="provider">Provider string. Example: Oracle.DataAccess.Client</param>
            <param name="connectionString">Connection String</param>
            <param name="tableName">Table Name in which the sequence needs to be created or already exists</param>
            <param name="missingSequenceAction">Action to indicate what the generator needs to do if the specified sequence doesn't exist.</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.MissingSequenceAction">
            <summary>
            Indicates the action to be performed if the specified sequences doesn't exist
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.MissingSequenceAction.Add">
            <summary>
            Add the sequence.
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Data.MissingSequenceAction.Error">
            <summary>
            Raises an <see>
                        <cref>T:SequenceNotFoundException</cref>
                      </see>  if the sequence doesn't exist.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplate">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.ToStringHelper">
            <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplateBase.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Data.TableBasedSequenceGeneratorTemplate.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.SnapshotCreated`4">
            <summary>
            Event that represents instance of snapshot being created 
            </summary>
            <typeparam name="TAggregate">Aggregate instance to be persisted as snapshot</typeparam>
            <typeparam name="TIdentity">Identity of Aggregate instance </typeparam>
            <typeparam name="TEvent">Type of events that helped Aggregate state to be prepared</typeparam>
            <typeparam name="TCommand">Type of commands that are executed on Aggregate instance</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.SnapshotCreated`4.#ctor">
            <summary>
            Initializes the instance of <see cref="T:Infrastructure.Seedwork.Domain.SnapshotCreated`4"/>
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.SnapshotCreated`4.#ctor(`0)">
            <summary>
            Initializes the instance of <see cref="T:Infrastructure.Seedwork.Domain.SnapshotCreated`4"/> 
            with the <see cref="T:Infrastructure.Seedwork.Domain.IAggregateRoot`3"/>
            for which snapshot is created.
            </summary>
            <param name="aggregate"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.SnapshotCreated`4.Aggregate">
            <summary>
            <see cref="T:Infrastructure.Seedwork.Domain.IAggregateRoot`3"/> instance which is persisted as snapshot.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.ExceptionCircuitBreaker">
            <summary>
            Logs exceptions only if the same exception did not occur in a specified time frame.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.ExceptionCircuitBreaker.LogInterval.Count">
            <summary>
            The number of occurrences of an exception at which the exception is logged.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.ExceptionCircuitBreaker.LogInterval.MaxAge">
            <summary>
            The time lag between logging an exceptions.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.ExceptionCircuitBreaker.LogInterval.MinAge">
            <summary>
            The minimum time lag between multiple logs of the same exception.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.ExceptionCircuitBreaker.ExceptionState">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.ExceptionCircuitBreaker.ExceptionState.#ctor(System.TimeSpan,System.Int32)">
            <summary>
            
            </summary>
            <param name="maxAge">Exceptions occurrences older than this are deleted.</param>
            <param name="maxOccurrences">
            The maximum number of occurrences to retain.
            </param>
        </member>
        <member name="P:Infrastructure.Seedwork.ExceptionCircuitBreaker.ExceptionState.Count">
            <summary>
            Returns number of occurences of the exception.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.ISerializer">
            <summary>
                Provides the ability to serialize and deserialize an object graph.
            </summary>
            <remarks>
                Instances of this class must be designed to be multi-thread safe such that they can be shared between threads.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.ISerializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
                Serializes the object graph provided and writes a serialized representation to the output stream provided.
            </summary>
            <typeparam name="T">The type of object to be serialized</typeparam>
            <param name="output">The stream into which the serialized object graph should be written.</param>
            <param name="graph">The object graph to be serialized.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.ISerializer.Deserialize``1(System.IO.Stream)">
            <summary>
                Deserializes the stream provided and reconstructs the corresponding object graph.
            </summary>
            <typeparam name="T">The type of object to be deserialized.</typeparam>
            <param name="input">The stream of bytes from which the object will be reconstructed.</param>
            <returns>The reconstructed object.</returns>
        </member>
        <member name="T:Infrastructure.Seedwork.ISystemEvent">
            <summary>
            Represents an event within the system.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.ISystemWarningEvent">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example>
            <code>
            [LocalizationRequiredAttribute(true)]
            public class Foo
            {
              private string str = "my string"; // Warning: Localizable string
            }
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/> class with
            <see cref="P:JetBrains.Annotations.LocalizationRequiredAttribute.Required"/> set to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/> class.
            </summary>
            <param name="required"><c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.Equals(System.Object)">
            <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/>.
            </summary>
            <param name="obj">The object to test the value equality of. </param>
            <returns>
            <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:JetBrains.Annotations.LocalizationRequiredAttribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A hash code for the current <see cref="T:JetBrains.Annotations.LocalizationRequiredAttribute"/>.</returns>
        </member>
        <member name="P:JetBrains.Annotations.LocalizationRequiredAttribute.Required">
            <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
            <example>
            <code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args)
            {
              //Do something
            }
            public void Foo()
            {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:JetBrains.Annotations.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one of the parameters
            of the caller function.
            For example, ReSharper annotates the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example>
            <code>
            public void Foo(string param)
            {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example>
             <code>
             public class Foo : INotifyPropertyChanged
             {
               public event PropertyChangedEventHandler PropertyChanged;
            
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName)
               {}
            
               private string _name;
               public string Name
               {
                 get { return _name; }
                 set
                 {
                   _name = value;
                   NotifyChanged("LastName"); // Warning
                 }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes, 
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example>
            <code>
            [CanBeNull]
            public object Test()
            {
              return null;
            }
            
            public void UseTest()
            {
              var p = Test(); 
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException' 
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example>
            <code>
            [NotNull]
            public object Foo()
            {
              return null; // Warning: Possible 'null' assignment
            } 
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted. <br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for method output means that the methos doesn't return normally. <br/>
            <c>canbenull</c> annotation is only applicable for output parameters. <br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute with rows separated by semicolon. <br/>
            </syntax>
            <examples>
            <list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // Regular Assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // String.IsNullOrEmpty
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list>
            </examples>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c> should be used instead.
            However, using '==' or '!=' for comparison with <c>null</c> is always permitted.
            </summary>
            <example>
            <code>
            [CannotApplyEqualityOperator]
            class NoEquality
            {
            }
            
            class UsesNoEquality
            {
              public void Test()
              {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
            
                if (ca1 != null) // OK
                {
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked with 
            the target attribute to implement or inherit specific type or types.
            </summary>
            <example>
            <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Annotations.BaseTypeRequiredAttribute.#ctor(System.Type)">
            <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
            <param name="baseType">Specifies which types are required</param>
        </member>
        <member name="P:JetBrains.Annotations.BaseTypeRequiredAttribute.BaseTypes">
            <summary>
            Gets enumerations of specified base types
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.UsedImplicitlyAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.MeansImplicitUseAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>
            Only entity marked with attribute considered used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>
            Indicates implicit assignment to a member
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>
            Members of entity marked with attribute are considered used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>
            Entity marked with attribute and all its members considered used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack. 
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
             <summary>
             Indicates that a method does not make any observable state changes.
             The same as <see cref="T:System.Diagnostics.Contracts.PureAttribute"/>
             </summary>
             <example>
             <code>
             [Pure]
             private int Multiply(int x, int y)
             {
               return x*y;
             }
            
             public void Foo()
             {
               const int a=2, b=2;
               Multiply(a, b); // Waring: Return value of pure method is not used
             }
             </code>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC action.
            If applied to a method, the MVC action name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC araa.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC controller.
            If applied to a method, the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Controller.View(String, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Controller.View(String, Object)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC partial view.
            If applied to a method, the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC view.
            If applied to a method, the MVC view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.Mvc.Controller.View(Object)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example>
            <code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl)
            {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <see cref="!:System.Web.WebPages.WebPageBase.RenderSection(String)"/>
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.LogPerformancePolicy">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.ReadOnlyCollection`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Infrastructure.Seedwork.EnumerableExtensions">
            <summary>
            Contains extensions methods for IEnumerable interface.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Applies the specified action over each item in the enumerable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="action"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Int32,``0})">
            <summary>
            Applies the specified action over each item in the enumerable. In addition to passing
            the item in the enumerable, the action is also given the index of the item in the enumerable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="action"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.EnumerableExtensions.OfType(System.Collections.IEnumerable,System.Type)">
            <summary>
            Returns only items that are of given targetType from source 
            </summary>
            <param name="source">Enumerable of items to be processed</param>
            <param name="targetType">Type of items to be filtered from source</param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException">
            <summary>
            The exception that is thrown when a aggregate version is not matching with the expected version.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException"/> class.
            </summary>
            <param name="version">Aggregate Version that caused exception to be raised</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException"/> class
             with a specified error message.
            </summary>
            <param name="message">A message that describes the error.</param>
            <param name="version">Aggregate Version that caused exception to be raised</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException.#ctor(System.String,System.Int32,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException"/> class 
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message that describes the error.</param>
            <param name="version">Aggregate Version that caused exception to be raised</param>
            <param name="inner">The exception that is the cause of the current exception. If the <paramref name="inner"/> parameter is not a null reference, 
            the current exception is raised in a catch block that handles the inner exception. </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException"/> class with serialized data.
            </summary>
            <param name="info">The object that holds the serialized object data. </param><param name="context">The contextual information about the source or destination. </param>
        </member>
        <member name="P:Infrastructure.Seedwork.Domain.InvalidAggregateVersionException.AggregateVersion">
            <summary>
            Aggregate Version that caused exception to be raised
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Messaging.ICommand">
            <summary>
            Represents a command message.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Messaging.IMessage">
            <summary>
            Marker interface to be implemented by objects representing a message.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Messaging.ICommand.Id">
            <summary>
            Gets the command identifier.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Messaging.ICommandBus">
            <summary>
            A bus that sends commands to respective command handlers.
            </summary>
            <remarks>
            <p>
            The commands sent on the bus could be executed in the same app domain, a different app domain in the
            same process or a different process on the same machine or a different process on another machine.
            </p>
            <p>
            There is no guarantee that all the commands will execute in the same process. Commands may be routed
            to different machines based on the bus configuration.
            </p>
            <p>
            The commands are usually executed asynchronously.
            </p>
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Messaging.ICommandBus.Send(Infrastructure.Seedwork.Messaging.ICommand)">
            <summary>
            Sends the specified command to the command handlers.
            </summary>
            <remarks>
            The command is sent to the handler aynchronously. So this method may return 
            before the command is executed.
            </remarks>
            <param name="command">
            The command to be sent. This must not be <c>null</c>.
            </param>
        </member>
        <member name="M:Infrastructure.Seedwork.Messaging.ICommandBus.Send(System.Collections.Generic.IEnumerable{Infrastructure.Seedwork.Messaging.ICommand})">
            <summary>
            Sends the specified commands to the respective command handlers.
            </summary>
            <remarks>
            <p>
            The bus implementation may choose to execute all the commands in the same unit of work.
            While this is not guaranteed, it will be honoured most of the times (unless the commands get
            routed to different machines/processes).
            </p>
            <p>
            So clients that want a batch of commands to be executed in a unit of work must use this method
            instead of calling <c>Send(ICommand)</c> in a loop.
            </p>
            </remarks>
            <param name="commands">
            The command to be sent. This must not be <c>null</c>.
            </param>
        </member>
        <member name="T:Infrastructure.Seedwork.Messaging.IEvent">
            <summary>
            Represents an event message.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Messaging.IEvent.SourceId">
            <summary>
            Gets the identifier of the source originating the event.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Messaging.IEventBus">
            <summary>
            A bus that publishes events.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Messaging.IEventBus.Publish(Infrastructure.Seedwork.Messaging.IEvent)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event to be published. This must not be <c>null</c>.</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Messaging.IEventBus.Publish(System.Collections.Generic.IEnumerable{Infrastructure.Seedwork.Messaging.IEvent})">
            <summary>
            Publishes the specified events.
            </summary>
            <param name="events">Events to be published. This must not be <c>null</c>.</param>
        </member>
        <member name="T:Infrastructure.Seedwork.PerformanceMetric">
            <summary>
            Utility class for measuring and logging performance.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.PerformanceMetric.Measure(System.String,System.Action)">
            <summary>
            Measures time taken for given action in milli seconds.
            </summary>
            <param name="description"></param>
            <param name="action">Block of code as <see cref="T:System.Action"/> to be measured</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.AndSpecification`1">
            <summary>
            A logic AND Specification
            </summary>
            <typeparam name="T">Type of entity that check this specification</typeparam>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.CompositeSpecification`1">
            <summary>
            Base class for composite specifications
            </summary>
            <typeparam name="TEntity">Type of entity that check this specification</typeparam>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.Specification`1">
            <summary>
            Represent an Expression Specification
            <remarks>
            Specification overload operators for create AND, OR or NOT specifications.
            Additionally overload AND and OR operators with the same sense of ( binary And and binary Or ).
            C# couldn’t overload the AND and OR operators directly since the framework doesn’t allow such craziness. But
            with overloading false and true operators this is posible. For explain this behavior please read
            http://msdn.microsoft.com/en-us/library/aa691312(VS.71).aspx
            </remarks>
            </summary>
            <typeparam name="TEntity">Type of item in the criteria</typeparam>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.ISpecification`1">
            <summary>
            The interface to be implemented by class that provide selection criteria for a given entity.
            </summary>
            <typeparam name="TEntity">The entity for which this interface provides selection criteria.</typeparam>
            <example>
            <code lang="C#" source="Infrastructure.Seedwork\Specification\CustomerEntity.txt"></code>
            </example>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ISpecification`1.SatisfiedBy">
            <summary>
            Returns the expression tree that evaluates an instance of <typeparamref name="TEntity"/> and
            returns <c>true</c> if the instance matches the criteria encapsulated by this specification.
            </summary>
            <returns>
            An expression tree that evalutes an instances of <typeparamref name="TEntity"/>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.SatisfiedBy">
            <summary>
            IsSatisFied Specification pattern method,
            </summary>
            <returns>Expression that satisfy this specification</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.op_BitwiseAnd(Infrastructure.Seedwork.Specification.Specification{`0},Infrastructure.Seedwork.Specification.Specification{`0})">
            <summary>
             And operator
            </summary>
            <param name="leftSideSpecification">left operand in this AND operation</param>
            <param name="rightSideSpecification">right operand in this AND operation</param>
            <returns>New specification</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.op_BitwiseOr(Infrastructure.Seedwork.Specification.Specification{`0},Infrastructure.Seedwork.Specification.Specification{`0})">
            <summary>
            Or operator
            </summary>
            <param name="leftSideSpecification">left operand in this OR operation</param>
            <param name="rightSideSpecification">left operand in this OR operation</param>
            <returns>New specification </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.op_LogicalNot(Infrastructure.Seedwork.Specification.Specification{`0})">
            <summary>
            Not specification
            </summary>
            <param name="specification">Specification to negate</param>
            <returns>New specification</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.op_False(Infrastructure.Seedwork.Specification.Specification{`0})">
            <summary>
            Override operator false, only for support AND OR operators
            </summary>
            <param name="specification">Specification instance</param>
            <returns>See False operator in C#</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.Specification`1.op_True(Infrastructure.Seedwork.Specification.Specification{`0})">
            <summary>
            Override operator True, only for support AND OR operators
            </summary>
            <param name="specification">Specification instance</param>
            <returns>See True operator in C#</returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.CompositeSpecification`1.LeftSideSpecification">
            <summary>
            Left side specification for this composite element
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.CompositeSpecification`1.RightSideSpecification">
            <summary>
            Right side specification for this composite element
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.AndSpecification`1.#ctor(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Default constructor for AndSpecification
            </summary>
            <param name="leftSide">Left side specification</param>
            <param name="rightSide">Right side specification</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.AndSpecification`1.SatisfiedBy">
            <summary>
            <see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/>
            </summary>
            <returns><see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.AndSpecification`1.LeftSideSpecification">
            <summary>
            Left side specification
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.AndSpecification`1.RightSideSpecification">
            <summary>
            Right side specification
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.DirectSpecification`1">
            <summary>
            A Direct Specification is a simple implementation
            of specification that acquire this from a lambda expression
            in  constructor
            </summary>
            <typeparam name="TEntity">Type of entity that check this specification</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.DirectSpecification`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Default constructor for Direct Specification
            </summary>
            <param name="matchingCriteria">A Matching Criteria</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.DirectSpecification`1.SatisfiedBy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.ExpressionBuilder">
            <summary>
            Extension methods for adding AND and OR with parameters rebinder
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ExpressionBuilder.Compose``1(System.Linq.Expressions.Expression{``0},System.Linq.Expressions.Expression{``0},System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Compose two expressions and merge all in a new expression
            </summary>
            <typeparam name="T">Type of params in expression</typeparam>
            <param name="first">Expression instance</param>
            <param name="second">Expression to merge</param>
            <param name="merge">Function to merge</param>
            <returns>New merged expression</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ExpressionBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            And operator
            </summary>
            <typeparam name="T">Type of params in expression</typeparam>
            <param name="first">Right Expression in AND operation</param>
            <param name="second">Left Expression in And operation</param>
            <returns>New AND expression</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ExpressionBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Or operator
            </summary>
            <typeparam name="T">Type of param in expression</typeparam>
            <param name="first">Right expression in OR operation</param>
            <param name="second">Left expression in OR operation</param>
            <returns>New Or expressions</returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.NamespaceDoc">
            <summary>
            Contains classes used for capturing the selection criteria of an entity.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.NotSpecification`1">
            <summary>
            NotEspecification convert a original
            specification with NOT logic operator
            </summary>
            <typeparam name="TEntity">Type of element for this specificaiton</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.NotSpecification`1.#ctor(Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Constructor for NotSpecificaiton
            </summary>
            <param name="originalSpecification">Original specification</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.NotSpecification`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Constructor for NotSpecification
            </summary>
            <param name="originalSpecification">Original specificaiton</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.NotSpecification`1.SatisfiedBy">
            <summary>
            <see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/>
            </summary>
            <returns><see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.OrSpecification`1">
            <summary>
            A Logic OR Specification
            </summary>
            <typeparam name="T">Type of entity that check this specification</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.OrSpecification`1.#ctor(Infrastructure.Seedwork.Specification.ISpecification{`0},Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Default constructor for AndSpecification
            </summary>
            <param name="leftSide">Left side specification</param>
            <param name="rightSide">Right side specification</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.OrSpecification`1.SatisfiedBy">
            <summary>
            <see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/>
            </summary>
            <returns><see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/></returns>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.OrSpecification`1.LeftSideSpecification">
            <summary>
            Left side specification
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Specification.OrSpecification`1.RightSideSpecification">
            <summary>
            Right side specification
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.ParameterRebinder">
            <summary>
            Helper for rebinder parameters without use Invoke method in expressions 
            ( this methods is not supported in all linq query providers, 
            for example in Linq2Entities is not supported)
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ParameterRebinder.#ctor(System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression})">
            <summary>
            Default construcotr
            </summary>
            <param name="map">Map specification</param>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ParameterRebinder.ReplaceParameters(System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Replate parameters in expression with a Map information
            </summary>
            <param name="map">Map information</param>
            <param name="exp">Expression to replace parameters</param>
            <returns>Expression with parameters replaced</returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.ParameterRebinder.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit pattern method
            </summary>
            <param name="p">A Parameter expression</param>
            <returns>New visited expression</returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.SpecificationConverter`2">
            <summary>
            Converts a specification on one <typeparamref name="TSourceEntity">entity</typeparamref> 
            into a specification on another <typeparamref name="TTargetEntity">entity</typeparamref>.
            </summary>
            <remarks>
            This would be useful if we define a specification on base class and want to convert to a specification on
            sub class (because a repository method be taking the sub class as input).
            </remarks>
            <typeparam name="TSourceEntity">The source class</typeparam>
            <typeparam name="TTargetEntity">The target class</typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.SpecificationConverter`2.TranslateSpecificationLambda`2">
            <summary>
            ExpressionVisitor that processes a lambda and converts it into another lambda.
            </summary>
            <remarks>
            This will be more useful if we remove the inheritance constraint. That would allow us to
            take a specification defined on a DTO class and apply it on a domain model class (the domain
            model class will never be a sub class of DTO class).
            </remarks>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TSubEntity"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.SpecificationExtensions">
            <summary>
            Contains fluent methods related to specification.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.SpecificationExtensions.And``1(Infrastructure.Seedwork.Specification.ISpecification{``0},Infrastructure.Seedwork.Specification.ISpecification{``0})">
            <summary>
            Combines two specifications with an <c>And</c> operation.
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.SpecificationExtensions.FilterBy``1(System.Linq.IQueryable{``0},Infrastructure.Seedwork.Specification.ISpecification{``0})">
            <summary>
            Fluent method to apply a specification on a query.
            </summary>
            <typeparam name="TEntity">Type of entity.</typeparam>
            <param name="query">Query to be filtered.</param>
            <param name="specification">Specification to be applied.</param>
            <returns>
            Query filtered by the specification.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.SpecificationExtensions.FindSpecification``2(Infrastructure.Seedwork.Specification.ISpecification{``0})">
            <summary>
            Utility method to support fluent specification API.
            </summary>
            <typeparam name="TEntity">Entity to which the specification applies to.</typeparam>
            <typeparam name="TSpecification">The specification type.</typeparam>
            <param name="specification">The specification to search.</param>
            <returns>
            The specification of the specified type or <c>null</c>.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.SpecificationExtensions.GetPropertyValues``2(Infrastructure.Seedwork.Specification.ISpecification{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts property values for the specified property from the specificat
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Specification.TrueSpecification`1">
            <summary>
            True specification
            </summary>
            <typeparam name="TEntity">Type of entity in this specification</typeparam>
        </member>
        <member name="M:Infrastructure.Seedwork.Specification.TrueSpecification`1.SatisfiedBy">
            <summary>
            <see cref="T:Infrastructure.Seedwork.Specification.Specification`1"/>
            </summary>
            <returns><see cref="T:Infrastructure.Seedwork.Specification.Specification`1"/></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.BaseSqlModelVisitor">
            <summary>
            Base class for <see cref="T:Infrastructure.Seedwork.Sql.ISqlModelVisitor"/> implementations.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ISqlModelVisitor">
            <summary>
            Interface to be implemented by classes that need to process sql statements.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.BaseSqlModelWriter">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ISqlModelWriter">
            <summary>
            Interface to be implemented by classes that write an sql model to a text stream.
            </summary>
            <see cref="T:Infrastructure.Seedwork.Sql.BaseSqlModelWriter"/>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.BinaryExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Expression">
            <summary>
            Base class for an SQL expression.
            </summary>
            <seealso cref="T:Infrastructure.Seedwork.Sql.ISqlModelVisitor"/>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.Expression.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            Implementation of the visitor pattern for sql expression trees.
            </summary>
            <param name="visitor">The visitor to accept.</param>
            <seealso cref="T:Infrastructure.Seedwork.Sql.ISqlModelVisitor"/>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.BooleanExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.BooleanExpression.#ctor(Infrastructure.Seedwork.Sql.Expression)">
            <summary>
            Operator defaults to BooleanOperator.And
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.BooleanExpression.#ctor(System.Collections.Generic.List{Infrastructure.Seedwork.Sql.Expression})">
            <summary>
            Operator defaults to BooleanOperator.And
            </summary>
            <param name="exprs"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.BooleanOperator">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.CaseExpression">
            <summary>
            <syntax>
            Case [Expression/Operand]
             When [condition/operand] Then [Result]
             Else Result
            End
            </syntax>
            <example>
            1. Case
                When x > y Then z 
                Else NULL
               End
            2. Case x
                When y Then z
                Else NULL
               End
            </example>
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.CaseExpression.Operand">
            <summary>
            Operand is optional.it is the value that we are comparing to the list of conditions.
             /// <example>
            1. Case
                When x > y Then z 
                Else NULL
               End        
               ** In this example we are omitting the Operand.
            2. Case x
                When y Then z
                Else NULL
               End
               ** In this example "x" is Operand. Condition would be "x = y".
            </example>       
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.CaseExpression.DefaultResult">
            <summary>
            DefaultResult is the value if no condition is found to be true, then the case statement will return this.      
            <example>
            1. Case
                When x > y Then z 
                Else Result
               End                
            2. Case x
                When y Then z
                Else Result
               End
               ** In above two example "Result" is the default result.
            </example>
            If the else clause is omitted and no condition is found to be true, then the Case statement will return Null. 
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ColumnExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ISupportAlias">
            <summary>
            Interface to be implemented by objects that can be aliased.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ConstantExpression">
            <summary>
            1. Create Expression class (say XXX)
                a. Extend Expression class
                b. Override Accept method
            2. ISqlModelVisitor - add a VisitXXX method
            3. BaseSqlModelVisitor - add VisitXXX method empty implementation
            4. BaseSqlModelWriter
                a. Add "protected abstract void WriteXXX(XXX expression)" method
                b. Modify "virtual void Write(Expression expression)" method to handle the new expression type
            5. OracleSqlModelWriter
                a. Add "protected override void WriteXXX(XXX expression)" method
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.LikeType">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.LikeType.StartsWith">
            <summary>
            
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.LikeType.EndsWith">
            <summary>
            
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.LikeType.Contains">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ExistsExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ExpressionExtensions">
            <summary>
            Extensions methods on <see cref="T:Infrastructure.Seedwork.Sql.Expression"/> class to provide fluent API.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.ExpressionExtensions.EqualTo(Infrastructure.Seedwork.Sql.Expression,Infrastructure.Seedwork.Sql.Expression)">
            <summary>
            Returns a <see cref="T:Infrastructure.Seedwork.Sql.BinaryExpression"/> that is creating by combining <paramref name="leftExpression"/>
            and <paramref name="rightExpression"/> using the <see cref="F:Infrastructure.Seedwork.Sql.Operator.Equal">equal</see> operator.
            </summary>
            <param name="leftExpression">left hand side expression.</param>
            <param name="rightExpression">right hand side expression.</param>
            <returns><see cref="T:Infrastructure.Seedwork.Sql.BinaryExpression"/> that combines <paramref name="leftExpression"/>
            and <paramref name="rightExpression"/> using the <see cref="F:Infrastructure.Seedwork.Sql.Operator.Equal">equal</see> operator.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.ExpressionExtensions.EqualTo(Infrastructure.Seedwork.Sql.Expression,System.String)">
            <summary>
            
            </summary>
            <param name="leftExpression"></param>
            <param name="stringLiteral"></param>
            <returns></returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.FluentSqlModelExtensions">
            <summary>
            Extension methods on <see cref="T:Infrastructure.Seedwork.Sql.SelectStatement"/>, <see cref="T:Infrastructure.Seedwork.Sql.Table"/>, etc. to support a
            fluent API.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.FromClause">
            <summary>
            Represents a <c>FROM</c> clause in an SQL <see cref="T:Infrastructure.Seedwork.Sql.SelectStatement"/>.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.FromClause.Table">
            <summary>
            The <see cref="P:Infrastructure.Seedwork.Sql.FromClause.Table"/> in this clause.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.FromClause.Joins">
            <summary>
            The <see cref="T:Infrastructure.Seedwork.Sql.Join"/> statements in this clause.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.FunctionCallExpression">
            <summary>
            Represents a function call in an SQL statement.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.FunctionCallExpression.AddArgument(Infrastructure.Seedwork.Sql.Expression)">
            <summary>
            Adds an argument to the function call.
            </summary>
            <param name="argExpression"></param>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.FunctionCallExpression.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            Support for visitor pattern.
            </summary>
            <param name="visitor">The visitor to be accepted. This must not be <c>null</c>.</param>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.FunctionCallExpression.FunctionName">
            <summary>
            Name of the function.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.FunctionCallExpression.Arguments">
            <summary>
            Arguments of the function.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.FunctionCallExpression.Alias">
            <summary>
            Alias of the expression.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.GroupByClause">
            <summary>
            Represents a <c>GROUP BY</c> clause in an SQL statement.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.GroupByClause.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            Implementation of the visitor pattern.
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.GroupByClause.GroupByExpressions">
            <summary>
            List of expressions in this clause.
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.InExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.ISqlFormatter">
            <summary>
            Defines the contract to be implemented by SQL formatters.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Join">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.JoinType">
            <summary>
            Defines the types of joins.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.JoinType.Inner">
            <summary>
            Inner Join
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.JoinType.LeftOuter">
            <summary>
            Left Outer Join
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.JoinType.RightOuter">
            <summary>
            Right Outer Join
            </summary>
        </member>
        <member name="F:Infrastructure.Seedwork.Sql.JoinType.Cross">
            <summary>
            Cross Join
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.LikeExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.AbstractLambdaExpressionTranslator`1">
            <summary>
            
            </summary>
            <typeparam name="TEntity"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.ITranslateLambdaExpression`1">
            <summary>
            Defines the contract to be implemented by classes that support translating an
            <see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/> to an <see cref="T:Infrastructure.Seedwork.Sql.Expression">sql expression</see>
            and a <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/> to an <see cref="T:Infrastructure.Seedwork.Sql.OrderByClause"/>.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.Linq.ITranslateLambdaExpression`1.Translate(Infrastructure.Seedwork.Specification.ISpecification{`0})">
            <summary>
            Translate an <see cref="T:Infrastructure.Seedwork.Specification.ISpecification`1"/> to an <see cref="T:Infrastructure.Seedwork.Sql.Expression"/>.
            </summary>
            <param name="specification">The specification to be translated.</param>
            <returns>
            The <see cref="T:Infrastructure.Seedwork.Sql.Linq.SpecificationTranslationResult">result</see> of the translation.
            </returns>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.Linq.ITranslateLambdaExpression`1.Translate(Infrastructure.Seedwork.Data.SortOrder{`0})">
            <summary>
            Translate a <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/> to <see cref="T:Infrastructure.Seedwork.Sql.OrderByClause"/>.
            </summary>
            <param name="sortOrder">
            The <see cref="T:Infrastructure.Seedwork.Data.SortOrder`1"/> to be translated.
            </param>
            <returns>
            The <see cref="T:Infrastructure.Seedwork.Sql.OrderByClause"/> representing the SQL version of <paramref name="sortOrder"/>.
            </returns>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.ITranslationContext">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.DictionaryExtensions">
            <summary>
            Extension methods on <c>Dictionary&lt;PropertyInfo, string&gt;</c> for
            registering properties using lambda expression.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.DummyQueryable`1">
            <summary>
            
            </summary>
            <typeparam name="TEntity"></typeparam>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.OperatorHelper">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.SpecificationTranslationResult">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Linq.WhereExpressionVisitor">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.LiteralExpression">
            <summary>
            Represents an sql literal expression.
            </summary>
            <remarks>
            This can be used for DISTINCT, *, etc.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.NestedJoin">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.NotInExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.NotLikeExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Operator">
            <summary>
            Defines the operators supported by a <see cref="T:Infrastructure.Seedwork.Sql.BinaryExpression"/>.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.OracleSqlModelWriter">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.OrderByClause">
            <summary>
            Represents an order by clause in SQL statement.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.OrderByClause.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            Accepts the visitor.
            </summary>
            <param name="visitor">The visitor to be accepted.</param>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.OrderByClause.OrderByExpressions">
            <summary>
            List of expressions in the order by clause.
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.Page.TotalItemsQuery">
            <summary>
            The total number of records in the full result set
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.Page.PagedQuery">
            <summary>
            The actual query to execute for paging
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.PredicateExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.PrettyTextSqlFormatter">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.PseudoColumnExpression">
            <summary>
            
            </summary>
            <author>Sairam Kambhala</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.SelectStatement">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Statement">
            <summary>
            
            </summary>
            <author>Shiva Kumar Gali</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.Statement.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.SqlServerModelWriter">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.SqlServerModelWriter.SetSqlServerVersion(Infrastructure.Seedwork.Sql.SqlServerVersion)">
            <summary>
            Sets <see cref="T:Infrastructure.Seedwork.Sql.SqlServerVersion"/>, that the user is targeting to generate queries
            </summary>
            <remarks>
            <see cref="T:Infrastructure.Seedwork.Sql.SqlServerVersion"/> plays key role in how paging is performed.
            </remarks>
            <param name="sqlServerVersion"><see cref="T:Infrastructure.Seedwork.Sql.SqlServerVersion"/> that the user if targeting to</param>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.StatementExpression">
            <summary>
            
            </summary>
            <author>Sairam Kambhala</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.StringPosition">
            <summary>
            Used for specifying the position of the string when using the <see cref="F:Infrastructure.Seedwork.Sql.Operator.Like">like</see> operator.
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.Table">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.Table.Database">
            <summary>
            This is usually required for SQL Server (optional).
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.TableReference">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.VariableExpression">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.View">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.PagedView">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.WhenClause">
            <summary>
            When clause is part of Case expression.
            <syntax>When [condition/operand] Then [Result]</syntax>
            </summary>
            
            <example>
            1. Case
                When x > y Then z 
                Else NULL
               End
            2. Case x
                When y Then z
                Else NULL
               End
            </example>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.WhenClause.Operand">
            <summary>
            Operand can be condition or a value that is equated with case operand.
            <example>
            1. Case
                When x > y Then z 
                Else NULL
               End        
               ** In this example "x > y" is Operand.
            2. Case x
                When y Then z
                Else NULL
               End
               ** In this example "y" is Operand. Condition would be "x = y".
            </example>            
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.WhenClause.Result">
            <summary>
            Result is the value returned once the conition is true.
            <example>
            1. Case
                When x > y Then z 
                Else NULL
               End                
            2. Case x
                When y Then z
                Else NULL
               End
               ** In above two example "z" is result if when condition is satisfied else "NULL".
            </example>            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.Sql.WhereClause">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.WhereClause.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Infrastructure.Seedwork.Sql.WhereClause.Accept(Infrastructure.Seedwork.Sql.ISqlModelVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Infrastructure.Seedwork.Sql.WhereClause.Predicate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.SystemDateTime">
            <summary>
            Helper class for simulating current <see cref="T:System.DateTime"/> while writing unit tests.
            </summary>
            <reamarks>
            Defaults to <see cref="P:System.DateTime.Now"/>.
            Helps unit test to simulate a command to be run as of a specific date.
            </reamarks>
            <author>Murali Poola</author>
        </member>
        <member name="M:Infrastructure.Seedwork.SystemDateTime.Reset">
            <summary>
            Resets <see cref="T:Infrastructure.Seedwork.SystemDateTime"/> to <see cref="P:System.DateTime.Now"/>
            </summary>
        </member>
        <member name="P:Infrastructure.Seedwork.SystemDateTime.Now">
            <summary>
            
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Infrastructure.Seedwork.SystemDateTime.DateTimeProvider">
            <summary>
            Provides ability to get/set delegate of type <see cref="T:System.Func`1"/>, 
            which determins current system date and time.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Infrastructure.Seedwork.SystemObserver">
            <summary>
            This class acts as an observer for system events and acts as an observable to others who are
            interested in the events.
            </summary>
            <remarks>
            TODO: This is a work in progress and requires more thought.
            </remarks>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.SystemEventArgs">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="M:Infrastructure.Seedwork.SystemEventArgs.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Infrastructure.Seedwork.MessageSystemEvent">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
        <member name="T:Infrastructure.Seedwork.SystemObservable">
            <summary>
            
            </summary>
            <author>Vamsee M Kamabathula</author>
        </member>
    </members>
</doc>
